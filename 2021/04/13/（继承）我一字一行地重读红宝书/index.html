<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    （继承）我一字一行地重读红宝书 |
    
    大大的小屋</title>
  
    <link rel="shortcut icon" href="/lindada-blog/fav.svg">
  
  
<link rel="stylesheet" href="/lindada-blog/css/style.css">

  
    
<link rel="stylesheet" href="/lindada-blog/fancybox/jquery.fancybox.min.css">

  
  
<script src="/lindada-blog/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/lindada-blog/atom.xml" title="大大的小屋" type="application/atom+xml">
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-（继承）我一字一行地重读红宝书" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      （继承）我一字一行地重读红宝书
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/lindada-blog/2021/04/13/%EF%BC%88%E7%BB%A7%E6%89%BF%EF%BC%89%E6%88%91%E4%B8%80%E5%AD%97%E4%B8%80%E8%A1%8C%E5%9C%B0%E9%87%8D%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6/" class="article-date">
  <time datetime="2021-04-13T05:04:20.000Z" itemprop="datePublished">2021-04-13</time>
</a>
                            
                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>【荷包蛋！荷包蛋！】</p>
<p>看过一遍《红宝书》，只不过仅对很多概念熟悉并不算是掌握。这一阵子的面试 JS 基础中都会问到继承，大概都讲个一知半解。所以打算一字一行再学习一遍。</p>
<a id="more"></a>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际具体的方法。</p>
<p>接口继承在 ECMAScript 中是不可能的，因为函数没有签名。因此 ECMAScript 主要通过原型链来实现继承。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>原型链</strong>是 ECMAScript 的主要继承方式，基本思想是通过原型继承多个引用类型的属性和方法。</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>构造函数、原型和实例的关系：</p>
<ul>
<li>每个构造函数都有一个 <code>prototype</code> 指向原型对象</li>
<li>原型有一个属性 <code>constructor</code> 指回构造函数</li>
<li>实例有一个内部指针 <code>__proto__</code> 指向原型</li>
</ul>
<blockquote>
<p>所以当原型作为是另一个构造函数的实例，则本身该原型也有一个内部指针指向<strong>上一个原型</strong>。这样就在实例和原型之间构造了一条原型链。</p>
</blockquote>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototyppe = <span class="literal">true</span>;	<span class="comment">// 构造函数定义属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型上定义方法</span></span><br><span class="line">SuperType.protytpe.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subpropertype = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型上定义子方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subpropertyp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance)	<span class="comment">// SuperType &#123; subpropertype: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue)	<span class="comment">// true（SuperType 上的属性）</span></span><br></pre></td></tr></table></figure>

<h4 id="小解析"><a href="#小解析" class="headerlink" title="小解析"></a>小解析</h4><blockquote>
<ul>
<li>以上代码定义了两个类型：<code>SuperType</code> 和 <code>SubType</code>。并分别定义了一个属性和一个方法。</li>
<li><code>SubType</code> 通过创建 <code>SuperType</code> 的实例并将其赋值给自己的原型，实现了对 <code>SuperType</code> 的继承。<ul>
<li><code>SuperType</code> 实例可以访问的所有属性和方法也会存在于 <code>SubType.prototype</code>上。</li>
</ul>
</li>
<li><code>SubType.prototype</code> 新增了一个方法<ul>
<li>也就是 <code>SuperType</code> 的实例上添加了一个新方法。</li>
</ul>
</li>
<li>最后创建了 <code>SubType</code> 的实例 <code>instance</code> 来查看继承过来的数据。<ul>
<li>调用实例 <code>instance.getSuperValue</code> 方法，可通过原型链向上查找。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><blockquote>
<ul>
<li><p><code>SubType</code> 将原型替换成 <code>SubPerType</code> 的实例 =&gt; <code>SubType</code> 的实例不仅能从 <code>SubperType</code> 的实例中即成属性</p>
</li>
<li><p>实例化出来的 <code>instance</code> 通过 <code>__proto__</code> 指向 <code>SubType</code> 的 <code>prototype</code></p>
</li>
<li><p><code>SubType.prototype</code> 指向 <code>SuperType.prototype</code></p>
<ul>
<li><blockquote>
<p><code>getSuperValue()</code> 方法还在 <code>SuperType.prototype</code> 对象上（是一个挂载在原型的方法）</p>
<p><code>prototype</code> 属性则在 <code>SubType.prototype</code> 上（是一个实例的属性）</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>SubType.prototype</code> 的 <code>constructor</code> 属性被重写为 <code>SuperType</code></p>
<ul>
<li><code>instance.constructor</code> 也指向 <code>SuperType</code></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="原型链扩展了原型搜索机制"><a href="#原型链扩展了原型搜索机制" class="headerlink" title="原型链扩展了原型搜索机制"></a>原型链扩展了原型搜索机制</h4><ul>
<li><p>在读取实例上的属性时，首先会在实例上搜索这个属性。如果没有找到，则会继承搜索实例的原型。</p>
</li>
<li><p>若是通过原型链实现继承之后，搜索就可以继承向上搜索原型的原型，会一直持续到原型链的末端。</p>
<ul>
<li>调用 <code>instance.getSuperValue()</code> 经过了 3 步的搜索：<ul>
<li><code>instance</code></li>
<li><code>SubType.prototype</code></li>
<li><code>SuperType.prototype</code>，在这里才找到了这个方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>实际上，默认情况下，所有引用类型都继承自 <code>Object</code>，这也是通过原型链实现的。</p>
<p>任何函数的默认原理都是一个 <code>Object</code> 的实例，这意味着这个实例有一个内部指针指向 <code>Object.prototype</code>。这也是为什么自定义类型能够继承包括 <code>toString()</code> 、<code>valueOf()</code> 在内的所有默认方法的原因。</p>
<blockquote>
<p>上一节的例子中，<code>SubType</code> 继承 <code>SuperType</code>，而 <code>SuperType</code> 继承 <code>Object</code>。在调用 <code>instance.toString()</code> 时，实际上调用的是保存在 <code>Object.protorype</code> 上的方法。</p>
</blockquote>
<h3 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h3><p>原型与实例的关系可以通过两种方式来确定。</p>
<blockquote>
<p>第一种方法是使用 <code>instanceof</code> 操作符。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上节例子</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType);	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从技术上来讲，instance 是 Object、SuperType 和 SubType 的实例，因此都返回 true。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种方法是使用 <code>isPrototypeOf()</code> 方法</p>
<p>原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，则返回 true</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上节例子</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="关于方法"><a href="#关于方法" class="headerlink" title="关于方法"></a>关于方法</h3><p>子类有时候需要覆盖父类的方法（形成多态），或者增加父类没有的方法（实现扩展）。</p>
<p>这些方法必须在原型赋值之后再添加到原型上。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototyppe = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.protytpe.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subpropertype = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型定义新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subpropertyp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖已有的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSubValue)	<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue)	<span class="comment">// false（覆盖方法）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>SubType</code> 的实例调用的是覆盖后的方法 =&gt; <code>false</code></p>
<p><code>SuperType</code> 的实例调用的是原先的方法 =&gt;<code>true</code></p>
<p>重点在于新方法需要在把原型赋值为 <code>SuperType</code> 的实例之后定义的</p>
</blockquote>
<h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><p>以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototyppe = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.protytpe.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subpropertype = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType =&gt; 原型是 SuperType 的实例</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">  getSubValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">  &#125;,</span><br><span class="line">  someOtherMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue)	<span class="comment">// 出错（原型链遭破坏，找不到 SuperType 原型）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码中，子类的原理在被赋值为 <code>SuperType</code> 的实例后，又被对象字面量覆盖了。</p>
<p><strong>覆盖后的原型是一个 <code>object</code> 的实例，而不再是 <code>SuperType</code>的实例。</strong></p>
<p>因此之前的原型链就断了。<code>SubType</code> 和 <code>SuperType</code> 之间也没有关系了。</p>
</blockquote>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>主要问题出现在原型中包含引用值的时候，原型中包含的引用值会在所有实例间共享。</p>
<p><strong>也就是为什么属性通常会在构造函数中定义而不会定义在原型上的原因</strong>，在使用原型继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)	<span class="comment">// 更改引用类型</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)	<span class="comment">// "red, blue, green, black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)	<span class="comment">// "red, blue, green, black"（噢ho！）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>SubType.prototype</code> 变成了 <code>SuperType</code> 的一个实例，因而也获得了自己的 <code>colors</code> 属性 =&gt; 类似于创建了 <code>SubType.prototype.colors</code> 属性。</p>
<p>但是，<code>SubType</code> 的所有实例都会共享这个 <code>colors</code> 属性。这一点通过 <code>instance1.colors</code> 上的修改也能反映到 <code>instance2.colors</code> 上就可以看出来</p>
</blockquote>
<p>第二个问题是，子类型在实例化时不能给父类型的构造函数传参。实际上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上原型中包含引用值的问题，导致原型链基本不会被单独使用，所有有了后边的继承的设计思维。</p>
<h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><p>盗用构造函数（constructor stealing），也被称为<strong>对象伪装</strong>或<strong>经典继承</strong>。用于解决原型包含引用值导致的继承问题。</p>
<p>大致基本思路为：在子类构造函数中调用父类构造函数。毕竟函数就是特定上下文中执行代码的简单对象，所以可以使用 <code>apply ()</code> 和 <code>call()</code> 方法以新创建的对象为上下文执行构造函数</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调继承 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)	<span class="comment">// "red, blue, green, black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)	<span class="comment">// "red, blue, green"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过使用改变 <code>this</code> 指向的方法，<code>SuperType</code> 构造函数在为 <code>SubType</code> 的实例创建的新对象的鹅上下文中执行了。</p>
<p>这相当于新的 <code>SubType</code> 对象上运行了 <code>SuperType()</code> 函数中的所有初始化代码，结果就是每个实例都会有自己的引用数据。（<code>colors</code> 属性）</p>
<p>当然也可以在调用 <code>SubType()</code> 构造函数时，传递参数。</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>主要缺点或问题，也就是使用构造函数模式自定义类型的问题：</p>
<ul>
<li>必须在构造函数中定义方法，因此函数不用重用。</li>
<li>子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。</li>
</ul>
<blockquote>
<p>所以盗用构造函数基本上虽说解决了原型链继承的引用类型的缺陷，但也不能单独使用。</p>
</blockquote>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（伪经典继承）其实也就是综合了原型链和盗用构造函数，将其优点集中。</p>
<p>基本思路：<strong>使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。</strong>这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链挂载方法</span></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 盗用函数来确保每个实例都有自己的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载新方法</span></span><br><span class="line">SuperType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Lindada"</span>, <span class="number">21</span>)</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)	<span class="comment">// "red, blue, green, black"</span></span><br><span class="line">instance1.sayName()	<span class="comment">// "Lindada"</span></span><br><span class="line">instance1.sayAge()	<span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Lindada2"</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)	<span class="comment">// "red, blue, green"</span></span><br><span class="line">instance2.sayName()	<span class="comment">// "Lindada2"</span></span><br><span class="line">instance2.sayAge()	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="小解析-1"><a href="#小解析-1" class="headerlink" title="小解析"></a>小解析</h3><blockquote>
<ul>
<li><code>SuperType</code> 构造函数定义了两个属性，<code>name</code> 和 <code>colors</code>，而原型上也定义了 <code>sayName()</code> 方法。</li>
<li><code>SubType</code> 构造函数调用了 <code>SuperType</code> 构造函数，传入了 <code>name</code> 参数，又定义了自己的属性 <code>age</code>。</li>
<li><code>SubType.prototype</code> 也被赋值为 <code>SuperType</code> 的实例，再在原型上添加了新方法<code>sayAge()</code>。</li>
<li>这样就让 <code>SubType</code> 的两个实例都有自己的属性同时还共享相同的方法。</li>
</ul>
</blockquote>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>Douglas Crockford 写的一篇文章《JavaScript 中的原型式继承》，介绍了一种不涉及严格意义上构造函数的继承方法。</p>
<p>出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个 <code>object()</code> 函数会创建一个<strong>临时构造函数</strong>，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。</p>
<p>本质上，<code>object()</code>是对传入的对象执行了一次浅复制。</p>
</blockquote>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lindada'</span>,</span><br><span class="line">  friends: [<span class="string">'ShuaiGe'</span>, <span class="string">'MeiNv'</span>, <span class="string">'LiangZai'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person)</span><br><span class="line">anotherPerson.name = <span class="string">'Lindada2'</span></span><br><span class="line">anotherPerson.friedns.push(<span class="string">'DaRen'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Lindada3'</span></span><br><span class="line">yetAnotherPerson.friedns.push(<span class="string">'XiaoRen'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends)	<span class="comment">// ['ShuaiGe', 'MeiNv', 'LiangZai', 'DaRen', 'XiaoRen']</span></span><br></pre></td></tr></table></figure>

<h3 id="小解析-2"><a href="#小解析-2" class="headerlink" title="小解析"></a>小解析</h3><p>原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 <code>object()</code>，然后再对返回的对象进行适当修改。</p>
<blockquote>
<ul>
<li><code>person</code> 对象定义了另一个对象也应该共享的信息，把它传给 <code>object()</code> 之后会返回一个新对象。</li>
<li>新对象的原型是 <code>person</code>，意味着它的原型上既有原始值属性又有引用值属性。</li>
<li>因此 <code>person.friends</code> 不仅是 <code>person</code> 的属性，也会跟 <code>anotherPerson</code> 和 <code>yetAnotherPerson</code> 共享。</li>
<li>这里实际上克隆了两个 <code>person</code>。</li>
</ul>
</blockquote>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>ECMAScript 5 通过增加 <code>Object.create()</code> 方法将原型式继承的概念规范化了。</p>
<p>方法接受两个参数：作为新对象原型的对象，给新对象定义额外属性的对象（可选）。</p>
<blockquote>
<p>若仅传入一个参数，则与上一节例子中的<code>object</code> 方法并无差别。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lindada'</span>,</span><br><span class="line">  friends: [<span class="string">'ShuaiGe'</span>, <span class="string">'MeiNv'</span>, <span class="string">'LiangZai'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">anotherPerson.name = <span class="string">'Lindada2'</span></span><br><span class="line">anotherPerson.friedns.push(<span class="string">'DaRen'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Lindada3'</span></span><br><span class="line">yetAnotherPerson.friedns.push(<span class="string">'XiaoRen'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends)	<span class="comment">// ['ShuaiGe', 'MeiNv', 'LiangZai', 'DaRen', 'XiaoRen']</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>传入第二个参数与 <code>Object.defineProperties()</code> 的第二个参数一样，每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lindada'</span>,</span><br><span class="line">  friends: [<span class="string">'ShuaiGe'</span>, <span class="string">'MeiNv'</span>, <span class="string">'LiangZai'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">"Lindada2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends)	<span class="comment">// ['ShuaiGe', 'MeiNv', 'LiangZai', 'DaRen', 'XiaoRen']</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原型式继承非常适合<strong>不许单独创建构造函数</strong>，但仍然需要再对象间共享信息的场合。</p>
<p>因此，属性中包含的引用值始终会再相关对象间共享，是跟使用原型模式是一样。</p>
</blockquote>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承（parasitic inheritance）与原型式继承比较接近。</p>
<p>基本思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(original)	<span class="comment">// 创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;	<span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone	<span class="comment">// 返回新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lindada'</span>,</span><br><span class="line">  friends: [<span class="string">'ShuaiGe'</span>, <span class="string">'MeiNv'</span>, <span class="string">'LiangZai'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi()	<span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure>

<h3 id="小解析-3"><a href="#小解析-3" class="headerlink" title="小解析"></a>小解析</h3><blockquote>
<ul>
<li><code>createAnother()</code> 方法给予 <code>person</code> 对象返回了一个新对象。</li>
<li>新返回的 <code>anotherPerson</code> 对象具有 <code>person</code> 的所有属性和方法，还有一个新方法叫 <code>sayHi()</code></li>
</ul>
</blockquote>
<p>寄生式继承同样适合主要关注对象，而不在乎类型的构造函数的场景。<code>Object.create()</code> 函数不是寄生式继承所必需的，任何返回对象的函数都可以在这里使用。</p>
<p>但通过此继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
<h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>组合继承有个主要的效率问题就是父类构造函数始终会被调用两次：</p>
<ul>
<li>创建子类原型时调用</li>
<li>子类构造函数中调用</li>
</ul>
<p>本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行。</p>
<h4 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)	<span class="comment">// 第二次调用 SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()	<span class="comment">// 第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小解析-4"><a href="#小解析-4" class="headerlink" title="小解析"></a>小解析</h4><blockquote>
<ul>
<li><code>SubType.prototype</code> 上会有两个属性：<code>name</code> 和 <code>colors</code>，均为 <code>SuperType</code> 的实例属性，现在成为 <code>SubType</code> 的原型属性。</li>
<li>调用 <code>SubType</code> 构造函数时，也会调用 <code>SuperType</code> 构造函数，这一次会在新对象上创建实例属性 <code>name</code> 和 <code>colors</code>。</li>
<li>这两个实例属性会遮蔽原型上同名的属性。</li>
<li>因此会造成两组 <code>name</code> 和 <code>colors</code> 属性：一组在实例上，一组在 <code>SubType</code> 的运行上。</li>
</ul>
</blockquote>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>寄生式组合继承通过盗用结构函数继承属性，且使用混合式原型链继承方法。</p>
<p>基本思路：<strong>使用寄生式继承来继承父类原型，将返回的新对象赋值给子类原型。</strong></p>
<p>基本模式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="built_in">Object</span>.create(superType.prototype)	<span class="comment">// 创建对象</span></span><br><span class="line">  prototype.constructor = subType	<span class="comment">// 增加对象</span></span><br><span class="line">  subType.prototype = prototype	<span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个函数接收两个参数：子类构造函数和父类构造函数。</p>
<ul>
<li><p>第一步创建父类原型的一个副本</p>
</li>
<li><p>第二步给返回的新对象 <code>prototype</code> 设置 <code>constructor</code> 属性，解决由于重写原型导致默认 <code>constructor</code> 丢失的问题</p>
</li>
<li><p>最后将新创建的对象赋值给子类型的原型</p>
</li>
</ul>
</blockquote>
<h4 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="built_in">Object</span>.create(superType.prototype)	<span class="comment">// 创建对象</span></span><br><span class="line">  prototype.constructor = subType	<span class="comment">// 增加对象</span></span><br><span class="line">  subType.prototype = prototype	<span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)	<span class="comment">// 调用一次 SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SubperType)</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小解析-5"><a href="#小解析-5" class="headerlink" title="小解析"></a>小解析</h4><blockquote>
<p>在原型链保持不变的基础上，这里只调用了一次 <code>SuperType</code> 构造函数，避免了 <code>SubType.prototype</code> 上不必要也用不到的属性。因此可以说这个例子的效率更高。</p>
<p>因此 <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code> 方法正常有效，综上寄生式组合继承可以算是<strong>引用类型继承的最佳模式</strong>。</p>
</blockquote>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>整理了一天，算是理解并一字一行打出来理清楚一遍。对于上边内容有本人精简概括，若是有不对或纰漏的地方，还望海涵和不吝指正。当然最好还是看《红宝书》进行一次详细阅读。</p>
<p>总之不知道下一次实习面试自己还能不能理的清楚，那就不断地回滚知识吧！</p>
<p>最后对自己加油～鹅鹅鹅鹅鹅</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        
                                            <!--MOB SHARE BEGIN-->
<a><div class="-mob-share-open article-share-link">分享</div></a>
<div class="-mob-share-ui" style="display: none; display: flex; align-items: center; align-content: center;">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
    </ul>
    <div style="height: 100%; width: 100%">
        <div class="-mob-share-close" style="position:relative; margin: -26em auto; width: 80px; height: 40px; font-size: 14px; color: #fff; background-color: #4593e9; border-radius: 15px;">取消</div>
    </div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="/lindada-blog/js/mob-share.js"></script>
<!--MOB SHARE END-->

                                        
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/lindada-blog/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/" rel="tag">红宝书</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/lindada-blog/2021/04/15/%E8%AE%B0%E3%80%8AGithub%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97%E9%98%85%E8%AF%BB%E3%80%8B%E6%9C%89%E6%84%9F/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            记《Github漫游指南阅读》有感
          
        </div>
      </a>
    
    
      <a href="/lindada-blog/2021/04/07/Canvas%E5%8A%A8%E7%94%BB%E5%B0%8Fdemo%EF%BC%88%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">Canvas动画小demo（从零到一）</div>
      </a>
    
  </nav>


            

                
                    
    <div class="vcomments" id="vcomments"></div>
    
<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

        <script>
            new Valine({
                el: '#vcomments',
                appId: 'vtOOBRQNx6g17peggpfzBROa-9Nh9j0Va',
                appKey: 'Q1DgaTCfUeYjMOqoTAH8TX9M',
                notify: 'false',
                verify: 'true',
                avatar: 'mp',
                pageSize: '20',
                placeholder: '✨悄悄地对小屋说...'
            })
        </script>
        
                        
                            

</article>

</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li>访客数 <i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li>阅读量 <i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>

    </div>
    <ul class="list-inline">
      <li>&copy; 2021 大大的小屋</li> |
      <li> Gitee主页 by <a href="https://gitee.com/lin_daren" target="_blank">林大大的Gitee</a></li> |
      <li> Wechat by <span class="footer-title">dadaLin_0809</span></li>
      <li> Email by <span class="footer-title">809751956@qq.com</span></li> |
    </ul>
  </div>
</footer>

<style>
    .footer-title {
        color: darkcyan;
        font-weight: bold;
    }
</style>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/lindada-blog/"><img src="/lindada-blog/images/star.svg" alt="大大的小屋"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/lindada-blog/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/lindada-blog/js/jquery-2.0.3.min.js"></script>


<script src="/lindada-blog/js/jquery.justifiedGallery.min.js"></script>


<script src="/lindada-blog/js/lazyload.min.js"></script>


<script src="/lindada-blog/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/lindada-blog/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/lindada-blog/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/lindada-blog/js/ocean.js"></script>


<script src="/lindada-blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/lindada-blog/live2dw/assets/assets/shizuku.model.json"},"display":{"position":"left","width":180,"height":360,"top":"-40px","right":"25px"},"mobile":{"show":true}});</script></body>
</html>
