<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    【变量、作用域与内存】-我一字一行地重读红宝书（四） |
    
    大大的小屋</title>
  
    <link rel="shortcut icon" href="/lindada-blog/fav.svg">
  
  
<link rel="stylesheet" href="/lindada-blog/css/style.css">

  
    
<link rel="stylesheet" href="/lindada-blog/fancybox/jquery.fancybox.min.css">

  
  
<script src="/lindada-blog/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/lindada-blog/atom.xml" title="大大的小屋" type="application/atom+xml">
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-【变量、作用域与内存】-我一字一行地重读红宝书（四）" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      【变量、作用域与内存】-我一字一行地重读红宝书（四）
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/lindada-blog/2021/04/19/%E3%80%90%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E3%80%91-%E6%88%91%E4%B8%80%E5%AD%97%E4%B8%80%E8%A1%8C%E5%9C%B0%E9%87%8D%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6%EF%BC%88%E5%9B%9B%EF%BC%89/" class="article-date">
  <time datetime="2021-04-19T06:54:27.000Z" itemprop="datePublished">2021-04-19</time>
</a>
                            
                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>历经两个多月断断续续地读完了JavaScript的经典书籍<strong>红宝书</strong> -《JavaScript高级程序设计（第4版）</p>
<p>详细地读完一遍后发觉整本书知识点全而泛，乍一想每一章的细节，还是略显模糊。</p>
<p>于是督促自己计划编写每一章的着重点再次加深印象和理解，顺便记录自己的所学所想所悟。方便自身利用电脑的快速搜索关键词来进行快速定位和学习，也希望能帮助到有需要的同学们哈。</p>
<p>若是想要系统仔细的学习，当然还是看原书比较好，我也是强烈推荐的噢！这里内容只当个人复习和总结。</p>
<p><em>提示: 一些个人主观认为不重要或不流行的章节将进行删减</em></p>
<a id="more"></a>

<h1 id="4-变量、作用域与内存"><a href="#4-变量、作用域与内存" class="headerlink" title="4. 变量、作用域与内存"></a>4. 变量、作用域与内存</h1><p>ECMA-262 规定，JavaScript 变量是松散型的，变量不过就是特定时间点一个特定值的名称而已。因此变量的值和数据类型在脚本生命周期内可以改变。这样的变量很有意思，很强大，当然也有不少问题。如下是本章重点内容</p>
<ul>
<li>通过变量使用原始值与引用值</li>
<li>理解执行上下文</li>
<li>理解垃圾回收</li>
</ul>
<h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1 原始值与引用值"></a>4.1 原始值与引用值</h2><p>ECMAScript 变量包含两种不同类型的数据：原始值和引用值。</p>
<ul>
<li>原始值：最简单的数据。<ul>
<li>上一章讨论了 ES6 中 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。</li>
<li>保存原始值的变量是<strong>按值</strong>访问的，我们操作的就是存储在变量中的实际值。</li>
</ul>
</li>
<li>引用值：由多个值构成的对象。<ul>
<li>与其他语言不通，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。</li>
<li>操作对象时，实际上操作的是对该对象的<strong>引用</strong>而非实际的对象本身。</li>
<li>保存引用值是变量是<strong>按引用</strong>访问的</li>
</ul>
</li>
</ul>
<blockquote>
<p>在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript 打破了一个惯例。</p>
</blockquote>
<h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1 动态属性"></a>4.1.1 动态属性</h3><p>原始值和引用值的定义方式很类似，创建一个变量，然后给它赋一个值。但引用值可以随时添加、修改和删除其属性和方法。而原始值不能有属性和方法，但不会因此而报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用值可以动态操作属性和方法</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"lindada"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);	<span class="comment">// "lindada"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始值无法动态操作属性和方法</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"lindada"</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);	<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。如下是这两种初始化方式的差异：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">"lindada"</span>;</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"lindada2"</span>);</span><br><span class="line">name1.age = <span class="number">21</span>;</span><br><span class="line">name2.age = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age);	<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age);	<span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1);	<span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2);	<span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2 复制值"></a>4.1.2 复制值</h3><p>原始值和引用值在通过变量赋值时也有所不同。</p>
<ul>
<li><p>原始值会被复制到新变量的位置，两个变量独立使用，互不干扰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br><span class="line">num1 = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2);	<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用值从一个变量赋给另一个变量时，存储的值也会被复制到新变量所在的位置。区别在于实际上复制的值是一个指针，它指向存储在堆内存中的对象。复制完成后，两个变量实际上指向同一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"lindada"</span>;</span><br><span class="line"><span class="comment">// 反映到 obj2 中。</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name);	<span class="comment">// "lindada"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h3><p><strong>ECMAScript 中所有函数的参数（原始值、引用值）都是按值传递的</strong>。操作与它们各自复制值规则一致。</p>
<ul>
<li><p>原始值参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);	<span class="comment">// 仍是 20，并非引用传递随之改变。</span></span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用值参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">"lindada"</span>;</span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = <span class="string">"lindada2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);	<span class="comment">// "lindada"</span></span><br><span class="line"><span class="comment">// 意味着没有改变引用值的引用，仍是指向 person 这个引用值的指针。故引用值参数也是按值传递的。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>ECMAScript 中函数的参数就是局部变量。</p>
</blockquote>
<h3 id="4-1-4-确定类型"><a href="#4-1-4-确定类型" class="headerlink" title="4.1.4 确定类型"></a>4.1.4 确定类型</h3><p>ECMAScript 有多种方法来确定变量是什么类型。该如何使用，看自身需求操作。</p>
<ul>
<li><p>typeof：判断原始值中的数据类型或判断是原始值还是引用值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"lindada"</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">let</span> u;</span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);	<span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);	<span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i);	<span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u);	<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);	<span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);	<span class="comment">// object</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>instanceof：如果已知变量为引用值，用于判断其原型链上是否为给定的引用类，也可用于判断自定义类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> color = [];</span><br><span class="line"><span class="keyword">const</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'/*/'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"lindada"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(color <span class="keyword">instanceof</span> <span class="built_in">Array</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof 检测原始值，则始终会返回 false。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.toString.call(): 判断某个对象之属于哪种内置类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数类型</span></span><br><span class="line"><span class="built_in">Function</span> fn()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(“test”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(fn); <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="comment">// 日期类型</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(date); <span class="comment">// "[object Date]"</span></span><br><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[hbc]at/gi</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(reg); <span class="comment">// "[object RegExp]"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2 执行上下文与作用域"></a>4.2 执行上下文与作用域</h2><ul>
<li><p>变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。</p>
<ul>
<li><strong>全局上下文</strong>是最外层的上下文，在浏览器中也就是 window 对象。</li>
<li>因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。</li>
<li>使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。</li>
</ul>
</li>
<li><p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会销毁）。</p>
</li>
<li><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下栈上。在函数执行完之后，上下栈会弹出该函数的上下文，将控制权返还给之前的执行上下文。</p>
</li>
<li><p>ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。</p>
</li>
<li><p>上下文中的代码在执行时，会创建变量对象的一个<strong>作用域链</strong>。</p>
<ul>
<li>这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。</li>
<li>代码正在执行的上下文的变量对象始终位于作用域链的最前端。</li>
<li>如果上下文是函数，则其<strong>活动对象</strong>用作变量对象<ul>
<li>活动对象最初只有一个定义变量：arguments（全局上下文中没有这个变量）。</li>
<li>作用域链的下一个变量对象是<strong>包含该变量对象</strong>的上下文，以此类推至全局上下文（始终是作用域链的最后一个变量对象）。</li>
</ul>
</li>
</ul>
</li>
<li><p>如下例子展示上述规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 该上下文可以访问 color、anotherColor 和 tempColor。</span></span><br><span class="line">    <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里可以访问 color、anotherColor。</span></span><br><span class="line">  swapColor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问 color。</span></span><br><span class="line">changeColor()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。</p>
<p>函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同访问规则。</p>
</blockquote>
<h3 id="4-2-2-变量声明"><a href="#4-2-2-变量声明" class="headerlink" title="4.2.2 变量声明"></a>4.2.2 变量声明</h3><p>ES6 之后，新增的 let 和 const 变量声明关键字成为了变量声明的首选。</p>
<h4 id="4-2-2-1-使用-var-的函数作用域声明"><a href="#4-2-2-1-使用-var-的函数作用域声明" class="headerlink" title="4.2.2.1 使用 var 的函数作用域声明"></a>4.2.2.1 使用 var 的函数作用域声明</h4><ul>
<li><p>在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。</p>
</li>
<li><p>如果变量未经声明就被初始化了，那么会被自动添加到全局上下文中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  sum2 = num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">20</span>, <span class="number">10</span>);	<span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);	<span class="comment">// 报错，该变量不在当前上下文中。</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2);	<span class="comment">// 10，sum2 在调用 add() 之后被添加到了全局上下文中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>未经声明而初始化变量在 JavaScript 中会导致很多问题，为此在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p>
</blockquote>
</li>
<li><p>var 声明会被拿到函数或全局作用域的顶部，这个现象叫做<strong>提升</strong>。在实践中，提升会导致合法却奇怪的现象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="built_in">console</span>.log(name);	<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"lindada"</span>;	<span class="comment">// 变量提升</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);	<span class="comment">// undefined</span></span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">"lindada"</span>;	<span class="comment">// 变量提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-2-2-2-使用-let-的块级作用域声明"><a href="#4-2-2-2-使用-let-的块级作用域声明" class="headerlink" title="4.2.2.2 使用 let 的块级作用域声明"></a>4.2.2.2 使用 let 的块级作用域声明</h4><ul>
<li><p>let 变量声明与 var 变量声明很相似，但它的作用域时块级的，由最近的一对包含花括号 <strong>{}</strong> 来界定，这也是 JavaScript 中的新概念。</p>
<ul>
<li>如 if 块、while 块、function 块，甚至单独的 {} 块作用域。</li>
</ul>
</li>
<li><p>let 不能在同一作用域内声明两次（var 则会覆盖声明）。</p>
</li>
<li><p>let 不会被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 该变量声明在块级作用域上</span></span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);	<span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复声明</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);	<span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量提升</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;	<span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>严格来说，let 在 JavaScript 运行时中也会被提升，但由于<strong>暂时性死区</strong>的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度来说，let 的提升跟 var 是不一样的。</p>
</blockquote>
</li>
</ul>
<h4 id="4-2-2-3-使用-const-的常量声明"><a href="#4-2-2-3-使用-const-的常量声明" class="headerlink" title="4.2.2.3 使用 const 的常量声明"></a>4.2.2.3 使用 const 的常量声明</h4><ul>
<li><p>使用 const 声明的变量必须同时初始化为某个值。</p>
</li>
<li><p>一经声明，在其生命周期的任何时候都不能再重新赋予新值（但对象的键则不受限制）。</p>
<ul>
<li>如果想要让整个对象都不能修改，可以使用 Object.freeze()，来静默对象修改失败。</li>
</ul>
</li>
<li><p>其余规则与 let 变量声明类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a;	<span class="comment">// SyntaxError，常量声明时没有初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);	<span class="comment">// 3</span></span><br><span class="line">b = <span class="number">4</span>;	<span class="comment">// TypeError，不能给常量变量赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1.name = <span class="string">'lindada'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1.name);	<span class="comment">// 'lindada'</span></span><br><span class="line">o1 = &#123;&#125;;	<span class="comment">// TypeError，不能给常量变量重新赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o2.name = <span class="string">'lindada'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1.name);	<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>谷歌的 V8 引擎会执行优化常量声明，故若仅一次赋值的变量，应尽可能多的使用 const 声明。</p>
</blockquote>
<h3 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3 垃圾回收"></a>4.3 垃圾回收</h3><p>JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。不像 C 和 C++ 等语言中需要跟踪内存使用，JavaScript 为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。</p>
<blockquote>
<p>简单思路来说：周期性地确定哪个变量不会再使用，然后释放占用的内存。</p>
</blockquote>
<p>不过判断某个变量是否还有用，属于不可判定的问题。但在浏览器的发展史上，用过两种主要的标记策略：标记清理和引用计数。</p>
<h3 id="4-3-1-标记清理"><a href="#4-3-1-标记清理" class="headerlink" title="4.3.1 标记清理"></a>4.3.1 标记清理</h3><p>这是 JavaScript 最常用的垃圾回收策略。当变量进入上下文时，该变量会被加上存在于上下文中的标记。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式的有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护 <strong>在上下文中</strong> 和 <strong>不在上下文中</strong> 两个变量列表，可以把变量从一个列表转移到另一个列表来进行标记。（但标记的过程并不重要，关键的是策略。）</p>
<p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了。（原因是任何在上下文中的变量都访问不到它们了）随后垃圾回收程序做一次 <strong>内存清理</strong>，销毁带标记的所有值并收回它们的内存。</p>
<blockquote>
<p>到 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。</p>
</blockquote>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a>4.3.2 引用计数</h3><p>另一种没那么常用的垃圾回收策略是<strong>引用计数</strong>，其思路是对每个值都记录它被引用的次数。</p>
<blockquote>
<p>一开始声明变量并给它赋一个引用值时，这个值的引用数为 1。若再次被赋给另一个变量，那么再加 1。</p>
<p>如果保存对该值引用的变量被其他值给覆盖了，那么引用值减 1.</p>
</blockquote>
<p>故当垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。</p>
<p>引用计数最早由 Netscape Navigator 3.0 采用，很快遇到了严重问题：<strong>循环引用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">porblem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj1.someOtherObject = obj2;</span><br><span class="line">  obj2.anotherObject = obj1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在函数结束后，虽然这两个对象都不在作用域中，但在引用计数策略下引用数总是 2。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要显示地将<strong>循环引用</strong>的对象设置为 null（会切断变量与其之前引用值之间的关系），才能清除循环引用。</p>
</blockquote>
<h3 id="4-3-3-性能"><a href="#4-3-3-性能" class="headerlink" title="4.3.3 性能"></a>4.3.3 性能</h3><p>垃圾回收程序会周期性运行，频繁的调用会造成性能损失，因此垃圾回收的时间调度很重要。因此最好的方法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。</p>
<p>V8 团队在 2016 年的一篇博文的说法：“在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收”</p>
<blockquote>
<p>类似于到达一定的阀值则进行调用回收。如 IE7 起始阀值与 IE6 相同，但如果垃圾回收程序回收的内存不到已分配的 15%，这些变量、字面量或者数组槽位的阀值就会翻倍（说明整个生命周期内变量很多）。如果有一次回收的内存达到已分配的 85%，则阀值重置为默认值</p>
<p>在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 IE 中，window.collectGarbage() 方法会立即触发垃圾回收。在 Opera7 及更高版本中，调用 window.opera.collect() 也会启动垃圾回收程序。</p>
</blockquote>
<h3 id="4-3-4-内存管理"><a href="#4-3-4-内存管理" class="headerlink" title="4.3.4 内存管理"></a>4.3.4 内存管理</h3><p>在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。但将内存占用量保持在一个较小的值可以让页面性能更好。因此优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。</p>
<h4 id="4-3-4-1-解除引用"><a href="#4-3-4-1-解除引用" class="headerlink" title="4.3.4.1 解除引用"></a>4.3.4.1 解除引用</h4><p>局部变量在超出作用域后就会被自动解除引用，但全局作用域的值不会，这个建议最适合全局变量和全局对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  localPerson.name = name;</span><br><span class="line">  <span class="keyword">return</span> localPerson</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在全局下创建的对象实例</span></span><br><span class="line"><span class="keyword">let</span> globalPerson = createPerson(<span class="string">"lindada"</span>);</span><br><span class="line"><span class="comment">// 解除 globalPerson 对值的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不过值得注意的值，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下一次垃圾回收时会被回收。</p>
</blockquote>
<h4 id="4-3-4-2-通过-const-和-let-声明提升性能"><a href="#4-3-4-2-通过-const-和-let-声明提升性能" class="headerlink" title="4.3.4.2 通过 const 和 let 声明提升性能"></a>4.3.4.2 通过 const 和 let 声明提升性能</h4><p>ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 const 和 let 都以块为作用域，相比于函数作用域或全局作用域更早地让垃圾回收程序释放内存空间。</p>
<h4 id="4-3-4-3-隐藏类和删除操作"><a href="#4-3-4-3-隐藏类和删除操作" class="headerlink" title="4.3.4.3 隐藏类和删除操作"></a>4.3.4.3 隐藏类和删除操作</h4><p>截止 2017 年，Chrome 是最流行的浏览器，采用的是 V8 JavaScript 引擎。V8 在将解释后的 JavaScript 代码编译成为实际的机器码会利用<strong>隐藏类</strong>。如果你的代码非常注重性能，那么这一点可能对你很重要。</p>
<p>在运行代码期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特性，进而能够共享相同隐藏类的对象性能会更好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">"msg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="comment">// V8 会在后台配置，让这两个类实例共享相同的隐藏类</span></span><br><span class="line"><span class="comment">// 共享同一个构造函数和原型</span></span><br><span class="line"></span><br><span class="line">a2.author = <span class="string">"lindada"</span>;</span><br><span class="line"><span class="keyword">delete</span> a2.author;</span><br><span class="line"><span class="comment">// 但增加或删除属性的操作，则两个实例就会对应两个不同的隐藏类</span></span><br><span class="line"></span><br><span class="line">a2.author = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 最佳的实例是把不需要的属性设置为 null。这样可以保持隐藏类不变和继续共享，且删除引用值供垃圾回收程序回收的效果。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-4-内存泄漏"><a href="#4-3-4-4-内存泄漏" class="headerlink" title="4.3.4.4 内存泄漏"></a>4.3.4.4 内存泄漏</h4><p>JavaScript 中的内存泄漏大部分是由不合理的引用导致的。</p>
<ul>
<li><p>意外声明全局变量</p>
<ul>
<li><pre><code class="js"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>) </span>{
  name = <span class="string">'lin'</span>    <span class="comment">// 等同于 window.name = 'lin'，应使用变量声明。</span>
}
&lt;!--￼<span class="number">17</span>--&gt;</code></pre>
</li>
<li><p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。</p>
</li>
</ul>
</li>
<li><p>闭包问题</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="keyword">let</span> name = <span class="string">'lin'</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> name
  }
}
&lt;!--￼<span class="number">18</span>--&gt;</code></pre>
</li>
<li><p>调用这个函数的时候会在堆上创建一个新对象，然后修改它，最后返回给调用者。当这个对象生命周期很短时，那么很快就会被垃圾回收掉，假如这个函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。</p>
</li>
<li><pre><code class="js"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b, resultant</span>) </span>{
  resultant.x = a.x + b.x
  resultant.y = a.y + b.y
  <span class="keyword">return</span> resultant
}
&lt;!--￼<span class="number">19</span>--&gt;</code></pre>
</li>
<li><p>如果对象池按需分配矢量（在对象不存在时创建新的，在对象存在时则复用），那么这个实现本质是一种贪婪算法，有单调增长但为静态的内存。对象池必须使用某种结构维护所有对象，因此<strong>数组</strong>是比较好的选择。不过使用数组必须留意不要招致额外的垃圾回收。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：静态配置是优化的一种极端形式，如果你的应用程序被垃圾回收严重地拖了后腿，可以考虑利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 变量可以保存两种类型的值：原始值和引用值。它们具有以下特点：</p>
<ul>
<li>原始值<ul>
<li>原始值大小固定，因此保存在栈内存上。</li>
<li>从一个变量到另一个变量复制原始值会创建该值的第二个副本。</li>
</ul>
</li>
<li>引用值<ul>
<li>引用值是对象，存储在堆内存上。</li>
<li>包含引用值的变量实际上只包含指向对应对象的一个指针，而不是对象本身。</li>
<li>从一个变量到另一个变量复制引用值只会复制指针，因此两个变量都指向同一个对象。</li>
</ul>
</li>
<li>typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型（也就是引用值的原型）。</li>
<li>Object.prototype.toString.call() 返回数据类型的内置对象，也可以返回自定义的数据类型</li>
</ul>
<p>任何变量都存在于某个执行上下文中（称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分，执行上下文可以总结如下。</p>
<ul>
<li>执行上下文分为全局上下文、函数上下文和块级上下文。</li>
<li>代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。</li>
<li>函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。</li>
<li>只能往上找，不能往下找。<ul>
<li>全局上下文只能访问全局上下文中的变量和函数，不能访问局部上下文的任何数据。</li>
<li>局部上下文可以访问本身上下文数据，也可以通过作用域链来访问全局上下文中的变量和函数。</li>
</ul>
</li>
<li>变量的执行上下文用于确定什么时候释放内存。</li>
</ul>
<p>JavaScript 是使用垃圾回收的编程语言，开发者不需要操作内存分配和回收。JavaScript 的垃圾回收程序可以总结如下：</p>
<ul>
<li>离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。</li>
<li>主流的垃圾回收算法是标记清理，即先给当前不适用的值加上标记，再回来回收它们的内存。</li>
<li>引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。<ul>
<li>因引用计数在代码中存在循环引用时会出现问题，JavaScript 引用不再使用这种算法。</li>
<li>某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象。</li>
</ul>
</li>
<li>解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        
                                            <!--MOB SHARE BEGIN-->
<a><div class="-mob-share-open article-share-link">分享</div></a>
<div class="-mob-share-ui" style="display: none; display: flex; align-items: center; align-content: center;">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
    </ul>
    <div style="height: 100%; width: 100%">
        <div class="-mob-share-close" style="position:relative; margin: -26em auto; width: 80px; height: 40px; font-size: 14px; color: #fff; background-color: #4593e9; border-radius: 15px;">取消</div>
    </div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="/lindada-blog/js/mob-share.js"></script>
<!--MOB SHARE END-->

                                        
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/lindada-blog/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/" rel="tag">红宝书</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
    
      <a href="/lindada-blog/2021/04/19/%E4%BA%8C%E6%9C%AC%E8%8E%B7%E5%BE%97%E5%AE%9E%E4%B9%A0offer%E7%BB%8F%E5%8E%86-%E5%87%86%E5%A4%87%E7%AF%87%EF%BC%88%E5%B7%B2%E8%8E%B7%E9%98%BF%E9%87%8C%E6%84%8F%E5%90%91%E4%B9%A6%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">二本获得实习offer经历-准备篇（已获阿里意向书）</div>
      </a>
    
  </nav>


            

                
                    
    <div class="vcomments" id="vcomments"></div>
    
<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

        <script>
            new Valine({
                el: '#vcomments',
                appId: 'vtOOBRQNx6g17peggpfzBROa-9Nh9j0Va',
                appKey: 'Q1DgaTCfUeYjMOqoTAH8TX9M',
                notify: 'false',
                verify: 'true',
                avatar: 'mp',
                pageSize: '20',
                placeholder: '✨悄悄地对小屋说...'
            })
        </script>
        
                        
                            

</article>

</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li>访客数 <i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li>阅读量 <i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>

    </div>
    <ul class="list-inline">
      <li>&copy; 2021 大大的小屋</li> |
      <li> Gitee主页 by <a href="https://gitee.com/lin_daren" target="_blank">林大大的Gitee</a></li> |
      <li> Wechat by <span class="footer-title">dadaLin_0809</span></li>
      <li> Email by <span class="footer-title">809751956@qq.com</span></li> |
    </ul>
  </div>
</footer>

<style>
    .footer-title {
        color: darkcyan;
        font-weight: bold;
    }
</style>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/lindada-blog/"><img src="/lindada-blog/images/star.svg" alt="大大的小屋"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/lindada-blog/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/lindada-blog/js/jquery-2.0.3.min.js"></script>


<script src="/lindada-blog/js/jquery.justifiedGallery.min.js"></script>


<script src="/lindada-blog/js/lazyload.min.js"></script>


<script src="/lindada-blog/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/lindada-blog/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/lindada-blog/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/lindada-blog/js/ocean.js"></script>


<script src="/lindada-blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/lindada-blog/live2dw/assets/assets/shizuku.model.json"},"display":{"position":"left","width":180,"height":360,"top":"-40px","right":"25px"},"mobile":{"show":true}});</script></body>
</html>
