<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    （第三章）我一字一行地重读红宝书 |
    
    大大的小屋</title>
  
    <link rel="shortcut icon" href="/lindada-blog/fav.svg">
  
  
<link rel="stylesheet" href="/lindada-blog/css/style.css">

  
    
<link rel="stylesheet" href="/lindada-blog/fancybox/jquery.fancybox.min.css">

  
  
<script src="/lindada-blog/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/lindada-blog/atom.xml" title="大大的小屋" type="application/atom+xml">
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-（第三章）我一字一行地重读红宝书" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      （第三章）我一字一行地重读红宝书
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/lindada-blog/2021/03/03/%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89%E6%88%91%E4%B8%80%E5%AD%97%E4%B8%80%E8%A1%8C%E5%9C%B0%E9%87%8D%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6/" class="article-date">
  <time datetime="2021-03-03T04:10:39.000Z" itemprop="datePublished">2021-03-03</time>
</a>
                            
                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>历经两个多月断断续续地读完了JavaScript的经典书籍<strong>红宝书</strong> -《JavaScript高级程序设计（第4版）</p>
<p>详细地读完一遍后发觉整本书知识点全而泛，乍一想每一章的细节，还是略显模糊。</p>
<p>于是督促自己计划编写每一章的着重点再次加深印象和理解，顺便记录自己的所学所想所悟。方便自身利用电脑的快速搜索关键词来进行快速定位和学习，也希望能帮助到有需要的同学们哈。</p>
<p>若是想要系统仔细的学习，当然还是看原书比较好，我也是强烈推荐的噢！这里内容只当个人复习和总结。</p>
<p><em>提示: 一些个人主观认为不重要或不流行的章节将进行删减</em></p>
<a id="more"></a>

<h1 id="3-语言基础"><a href="#3-语言基础" class="headerlink" title="3. 语言基础"></a>3. 语言基础</h1><p>ECMA-262 以一个名为 ECMAScript 伪语言的形式，定义了 JavaScript 的语法、操作符、数据类型和内置功能等。到2017年底，大多数主流浏览器几乎或全部实现了这一版的规范，为此，本章内容主要基于 ECMAScript 第6版。</p>
<h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><p>ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java 和 Perl。</p>
<h3 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1 区分大小写"></a>3.1.1 区分大小写</h3><p>在 ECMAScript 中一切都区分大小写，无论是变量、函数名还是操作符。类似地，typeof 不能作为函数名（因为是一个关键字），但 Typeof 是一个完全有效地函数名。</p>
<h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2 标识符"></a>3.1.2 标识符</h3><p>标识符就是变量、函数、属性或函数参数的名称。可以由一或多个下列字符组成:</p>
<ul>
<li>第一个字符必须是一个字母、下划线（_）或美元符号（$）。</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ul>
<p>标识符中的字母可以是扩展 ASCII 中的字母，也可以是 Unicode 的字母字符（但不推荐使用）。</p>
<p>ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。如: firstSecond、myCar。</p>
<blockquote>
<p>关键字、保留字、true、false 和 null 不能作为标识符。</p>
</blockquote>
<h3 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3 注释"></a>3.1.3 注释</h3><p>ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。</p>
<ul>
<li><pre><code class="js"><span class="comment">// 单行注释</span>
&lt;!--￼<span class="number">0</span>--&gt;
</code></pre>
</li>
</ul>
<h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4 严格模式"></a>3.1.4 严格模式</h3><p>ECMAScript 5 增加了严格模式的概念。ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。</p>
<p>在脚本文件的开头加上这一行即可声明: <strong>“use strict”;</strong> （一个预处理指令）</p>
<p>也可以单独指定一个函数在严格模式下执行，把预处理指令放到函数体开头即可:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格模式会影响 JavaScript 执行的很多方面且所有现代浏览器都支持严格模式。</p>
<h3 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5 语句"></a>3.1.5 语句</h3><ul>
<li><p>分号结尾</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> sum = a + b    <span class="comment">// 无分号有效，不推荐</span>
&lt;!--￼<span class="number">2</span>--&gt;

- 让解析器确定语句在哪里结尾，有助于防止省略造成的问题。
- 解析器会尝试在合适的位置补上分号以纠正语法错误，有助于在某些情况下提升性能。</code></pre>
</li>
</ul>
</li>
<li><p>代码块: 由一个左花括号（{）标识开始，一个右花括号（}）标识结束。</p>
<ul>
<li><pre><code class="js"><span class="keyword">if</span> (test)    <span class="comment">// 单条语句有效，但不推荐</span>
  <span class="built_in">console</span>.log(test);
&lt;!--￼<span class="number">3</span>--&gt;

- 在控制语句中使用代码块可以让内容更清晰，减少出错的可能性。
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2 关键字与保留字"></a>3.2 关键字与保留字</h2><p>ECMA-262 描述了一组保留的<strong>关键字</strong>具有一定的特定用途，按照规定，保留的关键字不能用做识别符或属性名。</p>
<p>ECMA-262 第 6 版规定的所有关键字如下：</p>
<blockquote>
<p>break    do    in    typeof    case    else    instanceof    var</p>
<p>catch    export    new    void    class    extends    return    while</p>
<p>const    finally    super    with    continue    for    switch    yield</p>
<p>debugger    function    this    default    if    throw    delete    import    try</p>
</blockquote>
<p><strong>未来的保留字</strong>，虽然在语言中没有特定用途，但它们是保留给将来作为关键字。</p>
<ul>
<li><p>始终保留</p>
<ul>
<li><blockquote>
<p>enum</p>
</blockquote>
</li>
</ul>
</li>
<li><p>严格模式下保留</p>
<ul>
<li><blockquote>
<p>implements    package    public</p>
<p>interface    protected    static</p>
<p>let    private</p>
</blockquote>
</li>
</ul>
</li>
<li><p>模块代码中保留</p>
<ul>
<li><blockquote>
<p>await</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h2><p>ECMAScript 变量是松散类型，是指变量可以用于保存任何类型的数据。有 3 个关键字可以声明变量：var、const 和 let。其中 var 在ECMAScript 所有版本中均可使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。</p>
<h3 id="3-3-1-var-关键字"><a href="#3-3-1-var-关键字" class="headerlink" title="3.3.1 var 关键字"></a>3.3.1 var 关键字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;	<span class="comment">// 定义了名为 message 的变量，可以用它保存任何类型的值。（不初始化的情况下，变量会保存一个特殊值 undefined）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>;</span><br><span class="line">message = <span class="number">100</span>;	<span class="comment">// 合法，但不推荐改变数据值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> messgae = <span class="string">"hi"</span>,</span><br><span class="line">    found = <span class="literal">false</span>,</span><br><span class="line">    age = <span class="number">29</span>;	<span class="comment">// 如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-1-1-var-声明作用域"><a href="#3-3-1-1-var-声明作用域" class="headerlink" title="3.3.1.1 var 声明作用域"></a>3.3.1.1 var 声明作用域</h4><p>使用 var 操作符定义的变量会成为包含它的函数的局部变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">"h1"</span>;	<span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message);	<span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-1-2-var-声明提升"><a href="#3-3-1-2-var-声明提升" class="headerlink" title="3.3.1.2 var 声明提升"></a>3.3.1.2 var 声明提升</h4><p>var 关键字声明的变量会自动提升到函数作用域顶部：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();	<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	之所以不会出错，是因为等效于如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();	<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，可以反复多次使用 var 声明同一个变量也没有问题，后者将覆盖前者。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">foo();	<span class="comment">// 36</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-let-声明"><a href="#3-3-2-let-声明" class="headerlink" title="3.3.2 let 声明"></a>3.3.2 let 声明</h3><p>let 关键字声明与 var 作用差不多，但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域，而 var 声明的范围是函数作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Matt'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name);	<span class="comment">// Matt</span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">console</span>.log(name);	<span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(age);	<span class="comment">// 26</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(age);	<span class="comment">// ReferenceError:	age没有定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let 也不允许用一个块作用域中出现重复声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name;	<span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;	<span class="comment">// SyntaxError:	标识符 age 已经声明过了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name;	<span class="comment">// SyntacError</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-1-暂时性死区"><a href="#3-3-2-1-暂时性死区" class="headerlink" title="3.3.2.1 暂时性死区"></a>3.3.2.1 暂时性死区</h4><p>let 声明的变量不会在作用域中被提升。在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name);	<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Matt'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(age);	<span class="comment">// ReferenceError: age 没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-2-全局声明"><a href="#3-3-2-2-全局声明" class="headerlink" title="3.3.2.2 全局声明"></a>3.3.2.2 全局声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Matt'</span>;	<span class="comment">// var 声明的变量会成为 window 对象的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);	<span class="comment">// 'Matt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;	<span class="comment">// let 声明的变量不会</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);	<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p>
</blockquote>
<h4 id="3-3-2-4-for-循环中的-let-声明"><a href="#3-3-2-4-for-循环中的-let-声明" class="headerlink" title="3.3.2.4 for 循环中的 let 声明"></a>3.3.2.4 for 循环中的 let 声明</h4><p>像类似于 for、for-in 和 for-of 循环的块作用域，var 和 let 声明变量通常会导致结果大为不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 是函数作用域，因此所有 i 一直为同一个变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;	<span class="comment">// 5、5、5、5、5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let 是块作用域，每次迭代循环都会声明一个新的迭代变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;	<span class="comment">// 0、1、2、3、4</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-const-声明"><a href="#3-3-3-const-声明" class="headerlink" title="3.3.3 const 声明"></a>3.3.3 const 声明</h3><p>const 声明与 let 声明基本一致，区分其重要区别如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须同时初始化变量</span></span><br><span class="line"><span class="keyword">const</span> age;	<span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能重复赋值</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line">age = <span class="number">36</span>;	<span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<p>const 声明的限制只适用于它指向的变量的引用，若 const 变量引用的是一个对象，那么是可以修改这个对象内部的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">'Matt'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4 声明风格及最佳实践"></a>3.3.4 声明风格及最佳实践</h3><ul>
<li>不使用 var<ul>
<li>有了 let 和 const，开发者应该限制自己只使用 let 和 const 有助于提升代码质量。<ul>
<li>有明确的作用域</li>
<li>声明位置</li>
<li>不变的值</li>
</ul>
</li>
</ul>
</li>
<li>const 优先，let 次之<ul>
<li>开发者应优先使用 const 来声明变量，只会提前知道未来会有修改时，再使用 let。<ul>
<li>让浏览器运行时强制保持变量不变</li>
<li>让静态代码分析工具提前发现不合法的赋值操作</li>
<li>更能迅速发现因意外赋值导致的非预期行为</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h2><p>简单的数据类型（也称为原始类型）</p>
<ul>
<li>ES6之前<ul>
<li>Undefined、Null、Number、String、Boolean</li>
</ul>
</li>
<li>ES6新增<ul>
<li>Symbol（符号）</li>
</ul>
</li>
<li>ES10新增<ul>
<li>BigInt</li>
</ul>
</li>
</ul>
<p>引用数据类型: Object（对象）是一种无序名值对的集合。</p>
<h3 id="3-4-1-typeof-操作符"><a href="#3-4-1-typeof-操作符" class="headerlink" title="3.4.1 typeof 操作符"></a>3.4.1 typeof 操作符</h3><p>因为 ECMAScript 的类型系统是松散，使用 typeof 操作符返回下列字符串之一</p>
<ul>
<li>“undefined” 表示值未定义</li>
<li>“boolean” 表示值为布尔值</li>
<li>“string” 表示值为字符串</li>
<li>“number” 表示值为数值</li>
<li>“object” 表示值为对象或 null</li>
<li>“function” 表示值为函数</li>
<li>“symbol” 表示值为符号</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"abc"</span>);	<span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>);	<span class="comment">// "number"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>typeof 是一个操作符而不是函数，所以不需要参数。</li>
<li>调用 typeof null 返回的是 “object”，这是因为特殊值 null 被认为是一个对空对象的引用。</li>
<li>严格来说，函数在 ECMAScript 中被认为是对象，并非一种数据类型。不过函数也有自己的特殊属性，因此有必要通过 typeof 操作符来区分函数和其他对象。</li>
</ul>
</blockquote>
<h3 id="3-4-2-Undefined-类型"><a href="#3-4-2-Undefined-类型" class="headerlink" title="3.4.2 Undefined 类型"></a>3.4.2 Undefined 类型</h3><p>Undefined 数据类型只有一个特殊值: undefined。</p>
<p>当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋于了 undefined 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;	<span class="comment">// 这个变量被声明，被赋于了 undefined 值</span></span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!message) &#123;</span><br><span class="line">  <span class="comment">// 这个块会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;	<span class="comment">// 未声明变量</span></span><br><span class="line">  <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-Null-类型"><a href="#3-4-3-Null-类型" class="headerlink" title="3.4.3 Null 类型"></a>3.4.3 Null 类型</h3><p>Null 数据类型只有一个特殊值:  null。</p>
<p>逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 “object” 的原因。因此定义将来要保存对象值的变量时，建议使用 null 来初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> cat);	<span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>undefined 值是由 null 值派生而来的，因此 console.log(null == undefined);    // true</li>
</ul>
</blockquote>
<h3 id="3-4-4-Boolean-类型"><a href="#3-4-4-Boolean-类型" class="headerlink" title="3.4.4 Boolean 类型"></a>3.4.4 Boolean 类型</h3><p>Boolean 数据类型有两个字面值: true 和 false（区分大写）。</p>
<p>在所有其他 ECMAScript 类型的值都有相应布尔值的等价形式，调用特定的 Boolean() 转型函数或 !! 隐形转换。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为 true 的值</th>
<th>转换为 false 的值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“ “（空字符串）</td>
</tr>
<tr>
<td>Number</td>
<td>非零数值</td>
<td>0、NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>N/A（无）</td>
<td>undefined</td>
</tr>
</tbody></table>
<h3 id="3-4-5-Number-类型"><a href="#3-4-5-Number-类型" class="headerlink" title="3.4.5 Number 类型"></a>3.4.5 Number 类型</h3><p>Number 类型使用 IEEE 754 格式表示整数和浮点数（在某些语言中也叫双精度值）。</p>
<ul>
<li><p>十进制整数：直接写出即可</p>
<ul>
<li>let intNum = 55;</li>
</ul>
</li>
<li><p>八进制整数：第一个数字必须是零（0）+ 相应的八进制数字（0～7）。否则将当成十进制处理。</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>;    <span class="comment">// 八进制 56</span>
<span class="keyword">let</span> octalNum2 = <span class="number">079</span>;    <span class="comment">// 无效八进制值，当成 79 处理</span>
&lt;!--￼<span class="number">17</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（-0），在所有情况下都被认为是等同的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> == <span class="number">0</span>)	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> === <span class="number">0</span>)	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-4-5-1-浮点值"><a href="#3-4-5-1-浮点值" class="headerlink" title="3.4.5.1 浮点值"></a>3.4.5.1 浮点值</h4><p>定义浮点值，数值中必须包含小数点。</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> floatNum1 = <span class="number">0.1</span>;
<span class="keyword">let</span> floatNum2 = <span class="number">.1</span>;    <span class="comment">// 有效，但不推荐</span>
&lt;!--￼<span class="number">19</span>--&gt;
</code></pre>
</li>
</ul>
<blockquote>
<p>浮点数的精确值最高可达 17 位小数，但在算术计算中因机器码的浮点操作，往往会造成微小的舍入错误。</p>
<p>如 0.1 + 0.2 得不到 0.3，而是0.300 000 000 000 000 04。<strong>故不要测试某个特定的浮点值</strong></p>
</blockquote>
<h4 id="3-4-5-2-值的范围"><a href="#3-4-5-2-值的范围" class="headerlink" title="3.4.5.2 值的范围"></a>3.4.5.2 值的范围</h4><ul>
<li><p>ECMAScript 可以表示的最小的数值：Number.MIN_VALUE 为 5e-324。</p>
</li>
<li><p>最大的数值：Number.MAX_VALUE 为 1.797 693 134 862 315 7e+308。</p>
</li>
<li><p>若某个计算超出了 JavaScript 可以表示的范围，将会自动转换为特殊的 Infinity 和 -Infinity，该值将不能再进一步用于任何计算。</p>
</li>
<li><p>要确定一个值是不是有限大（介于 JavaScript 能表示的范围中），使用 isFinite() 函数</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> InfinityNum = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;
<span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(InfinityNum));    <span class="comment">// 如果参数是 NaN，正无穷大或者负无穷大，会返回 false，其他返回 true。</span>
&lt;!--￼<span class="number">20</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>若分子非 0 值，分母为 0 或 -0 则返回无穷值</p>
<ul>
<li><pre><code class="js"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>);    <span class="comment">// Infinity</span>
<span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">-0</span>);    <span class="comment">// -Infinity</span>
&lt;!--￼<span class="number">21</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-5-4-数值转换"><a href="#3-4-5-4-数值转换" class="headerlink" title="3.4.5.4 数值转换"></a>3.4.5.4 数值转换</h4><p>Number()、parseInt() 和 parseFloat()，可以将非数值转换为数值。</p>
<ul>
<li><p>Number() 函数基于如下规则执行转换。</p>
<ul>
<li><p>布尔值，true 转换为 1，false 转换为 0。</p>
</li>
<li><p>数值，直接返回。</p>
</li>
<li><p>null，返回 0.</p>
</li>
<li><p>undefined，返回 NaN。</p>
</li>
<li><p>字符串，应用如下规则。</p>
<ul>
<li><p>字符串为数值字符（包含前缀有 +、- 情况），转换为一个十进制数值。</p>
<ul>
<li><pre><code class="js"><span class="built_in">Number</span>(<span class="string">"1"</span>);    <span class="comment">// 1</span>
<span class="built_in">Number</span>(<span class="string">"0123"</span>);    <span class="comment">// 123</span>
&lt;!--￼<span class="number">22</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>字符串包含有效的十六进制格式数值，则会转换为与该进制对应的十进制整数数值。</p>
<ul>
<li><pre><code class="js"><span class="built_in">Number</span>(<span class="string">"0xf"</span>);    <span class="comment">// 15</span>
&lt;!--￼<span class="number">23</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过第二个参数，可以极大扩展转换后获得的结果类型</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>, <span class="number">16</span>);    <span class="comment">// 175</span>
<span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>);    <span class="comment">// NaN，未指定底数不能省略前缀。</span>
<span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">2</span>);    <span class="comment">// 2, 按二进制解析。</span>
<span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">8</span>);    <span class="comment">// 8, 按八进制解析。</span>
<span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">10</span>);    <span class="comment">// 10, 默认按十进制解析。</span>
<span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">16</span>);    <span class="comment">// 16, 按十六进制解析。</span>
&lt;!--￼<span class="number">24</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-6-String-类型"><a href="#3-4-6-String-类型" class="headerlink" title="3.4.6 String 类型"></a>3.4.6 String 类型</h3><p>String 数据类型表示零或多个 16 位 Unicode 字符序列，字符串可以如下三种形式表示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">"Lindada"</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'Lindada'</span>;</span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">`Lindada`</span>;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 语法中表示三种形式的字符串对字符串的解释与某些语言不同，呈现的结果是相同的。</p>
<h4 id="3-4-6-1-字符字面量"><a href="#3-4-6-1-字符字面量" class="headerlink" title="3.4.6.1 字符字面量"></a>3.4.6.1 字符字面量</h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表示：</p>
<table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠（\）</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号（’）</td>
</tr>
<tr>
<td>\“</td>
<td>双引号（”）</td>
</tr>
<tr>
<td>\`</td>
<td>反引号（`）</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如 \x4 等于 “A”</td>
</tr>
<tr>
<td>\unnnn</td>
<td>以十六进制编码 nnnn 表示的 Unicode 字符，例如 \u03a3 等于希腊字符”Σ”</td>
</tr>
</tbody></table>
<blockquote>
<p>字符串的长度可以通过其 length 属性获取，但如果字符串中包含双字节字符，那么 length 属性返回的值可能不是准确的字符数，后边第 5 章将具体讨论。</p>
</blockquote>
<h4 id="3-4-6-2-字符串的特点"><a href="#3-4-6-2-字符串的特点" class="headerlink" title="3.4.6.2 字符串的特点"></a>3.4.6.2 字符串的特点</h4><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，值便无法修改了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">"Java"</span>;</span><br><span class="line">lang += <span class="string">"Script"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量 lang 一开始为 "Java" 字符串，随后 lang 变量被修改定义为 "JavaScript" 字符串。</span></span><br><span class="line"><span class="comment"> * 这意味着修改的整个过程首先会先分配一个足够容纳 10 个字符的空间，填充上 "Java" 和 "Script"，最后销毁原始的字符串 "Java" 和 "Script"。</span></span><br><span class="line"><span class="comment"> * 所有处理均在后台发生完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-6-3-转换为字符串"><a href="#3-4-6-3-转换为字符串" class="headerlink" title="3.4.6.3 转换为字符串"></a>3.4.6.3 转换为字符串</h4><p>有两种方式把一个值转换为字符串，toString() 方法和 String 转型函数。</p>
<ul>
<li><p>toString()：返回当前值的字符串等价物。</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> age = <span class="number">11</span>;
<span class="keyword">let</span> age2Str = age.toString();    <span class="comment">// "11"</span>
<span class="keyword">let</span> found = <span class="literal">true</span>;
<span class="keyword">let</span> found2Str = found.toString();    <span class="comment">// "true"</span>
&lt;!--￼<span class="number">27</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>String()：当不确定一个值是否具有 toString() 方法时（null 或 undefined），可以使用 String() 转型函数。</p>
<ul>
<li><p>函数遵循如下规则：</p>
<ul>
<li>如果值有 toString() 方法，则直接调用该方法（不传参数）并返回结果。</li>
<li>如果值是 null，返回 “null”。</li>
<li>如果值是 undefined，返回 “undefined”。</li>
</ul>
</li>
<li><p>如下例子：</p>
<ul>
<li><pre><code class="js"><span class="built_in">String</span>(<span class="number">10</span>);    <span class="comment">// "10"</span>
<span class="built_in">String</span>(<span class="literal">true</span>);    <span class="comment">// "true"</span>
<span class="built_in">String</span>(<span class="literal">null</span>);    <span class="comment">// "null"</span>
<span class="built_in">String</span>(<span class="literal">undefined</span>);    <span class="comment">// "undefined"</span>
&lt;!--￼<span class="number">28</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>模版字面量在定义模版时特别有用，比如下面这个 HTML 模版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">	&lt;a href="#"&gt;</span></span><br><span class="line"><span class="string">		&lt;span&gt;Jake&lt;/span&gt;</span></span><br><span class="line"><span class="string">	&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于模版字面量会保持反引号内部的空格，所以格式正确的模版字符串应不带有缩进。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">																second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(multiLineTemplateLiteral.length);	<span class="comment">// 38</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-6-5-字符串插值"><a href="#3-4-6-5-字符串插值" class="headerlink" title="3.4.6.5 字符串插值"></a>3.4.6.5 字符串插值</h4><p>技术上讲，模版字面量不是字符串，而是一种特殊的 JavaScript 语法表达式。在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p>
<ul>
<li><p>字符串插值通过在 ${} 中使用一个 JavaScript 表达式实现：</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> value = <span class="number">5</span>;
<span class="keyword">let</span> str = <span class="string">'second'</span>;
<span class="comment">// 以前，实现字符串插值。</span>
<span class="keyword">let</span> interpolatedStr = value + <span class="string">' to the '</span> + str + <span class="string">'power is '</span> + (value * value);
<span class="comment">// 5 to the second power is 25</span>

<span class="comment">// 现在，使用模版字面量</span>
<span class="keyword">let</span> interpolatedTemplateLiteral = <span class="string">`<span class="subst">${value}</span> to the <span class="subst">${str}</span> power is <span class="subst">${value * value}</span>`</span>;
<span class="comment">// 5 to the second power is 25</span>
&lt;!--￼<span class="number">31</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-6-6-模版字面量标签函数"><a href="#3-4-6-6-模版字面量标签函数" class="headerlink" title="3.4.6.6 模版字面量标签函数"></a>3.4.6.6 模版字面量标签函数</h4><p>模版字面量支持定义<strong>标签函数</strong>，标签函数会接收被插值记号分隔后的模版和对每个表达式求值的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, aVal, bVal, sumVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="built_in">console</span>.log(aVal);</span><br><span class="line">  <span class="built_in">console</span>.log(bVal);</span><br><span class="line">  <span class="built_in">console</span>.log(sumVal);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">'value'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> untaggedRes = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedRes = simpleTag<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// ["", " + ", " = ", ""]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(untaggedRes);	<span class="comment">// "6 + 9 = 15"</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedRes);	<span class="comment">// "value"</span></span><br></pre></td></tr></table></figure>

<p>若不确定标签函数中的参数，可以使用剩余操作符（…）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(strings[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> strings[<span class="number">0</span>] +</span><br><span class="line">		expressions.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;v&#125;</span><span class="subst">$&#123;strings[i + <span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;v&#125;</span><span class="subst">$&#123;strings[i + <span class="number">1</span>]&#125;</span>`</span>&#125;)</span><br><span class="line">		.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> untaggedRes = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedRes = simpleTag<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// ""</span></span><br><span class="line"><span class="comment">// "6 + "</span></span><br><span class="line"><span class="comment">// "9 = "</span></span><br><span class="line"><span class="comment">// "15"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(untaggedRes);	<span class="comment">// "6 + 9 = 15"</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedRes);	<span class="comment">// "6 + 9 = 15"</span></span><br></pre></td></tr></table></figure>



<h4 id="3-4-6-7-原始字符串"><a href="#3-4-6-7-原始字符串" class="headerlink" title="3.4.6.7 原始字符串"></a>3.4.6.7 原始字符串</h4><p>使用模版字面量也可以直接获取原始的模版字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此可以使用默认的 String.raw 标签函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode 示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>);	<span class="comment">// ©</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>);	<span class="comment">// \u00A9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line\nsecond line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>);	<span class="comment">// "first line\nsecond line"</span></span><br></pre></td></tr></table></figure>

<p>也可通过标签函数的第一个参数，即字符串数组的 .raw 属性取得每个字符串的原始内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRaw</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Actual characters:'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(string);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Escaped characters:'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.raw) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rawString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123;<span class="string">'and'</span>&#125;</span>\n`</span>;</span><br><span class="line"><span class="comment">// Actual characters:</span></span><br><span class="line"><span class="comment">// ©</span></span><br><span class="line"><span class="comment">// (换行符)</span></span><br><span class="line"><span class="comment">// Escaped characters:</span></span><br><span class="line"><span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-7-Symbol-类型"><a href="#3-4-7-Symbol-类型" class="headerlink" title="3.4.7 Symbol 类型"></a>3.4.7 Symbol 类型</h3><p>Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号的实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，进而用作非字符串形式的对象属性，不会发生属性冲突的危险。</p>
<h4 id="3-4-7-1-符号的基本用法"><a href="#3-4-7-1-符号的基本用法" class="headerlink" title="3.4.7.1 符号的基本用法"></a>3.4.7.1 符号的基本用法</h4><p>符号需要使用 Symbol() 函数初始化，可以传入一个字符串参数对符号的描述，可通过这个描述来调试代码，但<strong>描述与符号定义或标识完全无关</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Symbol</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym);	<span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2);	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> sym4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym3 === sym4);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>Symbol() 函数不能用作构造函数，与 new 关键字使用，为避免创建符号包装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>();	<span class="comment">// TypeError: Symbol is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若确实需要符号包装对象，可以借助 Object() 函数</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSymbol);	<span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-7-2-使用全局符号注册表"><a href="#3-4-7-2-使用全局符号注册表" class="headerlink" title="3.4.7.2 使用全局符号注册表"></a>3.4.7.2 使用全局符号注册表</h4><ul>
<li><p>Symbol.for() 方法：运行时的不同部分需要共享和重用符号的实例，那么可以使用一个符号串作为键。</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);
<span class="comment">// 后续使用相同字符串的调用会检查注册表，但会对应该符号的实例</span>
<span class="keyword">let</span> otherGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);
<span class="comment">// 即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol() 定义的符号也并不相同</span>
<span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);

<span class="built_in">console</span>.log(<span class="keyword">typeof</span> fooGlobalSymbol);    <span class="comment">// symbol</span>
<span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol);    <span class="comment">// true</span>
<span class="built_in">console</span>.log(fooGlobalSymbol === localSymbol);    <span class="comment">// false</span>
&lt;!--￼<span class="number">38</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-7-3-使用符号作为属性"><a href="#3-4-7-3-使用符号作为属性" class="headerlink" title="3.4.7.3 使用符号作为属性"></a>3.4.7.3 使用符号作为属性</h4><ul>
<li><p>凡事可以使用字符串或数值作为属性的地方，都可以使用符号替代。包括对象字面量属性和 Object.defineProperty() / Object.definedProperties() 定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>),
    s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);

<span class="keyword">let</span> o = {
  [s1]: <span class="string">'foo val'</span>
};
<span class="keyword">let</span> o[s1] = <span class="string">'foo val'</span>;
<span class="built_in">Object</span>.defineProperty(o, s1, {<span class="attr">value</span>: <span class="string">'foo val'</span>});
<span class="built_in">Object</span>.defineProperties(o, {
  [s1]: {<span class="attr">value</span>: <span class="string">'foo value'</span>},
  [s2]: {<span class="attr">value</span>: <span class="string">'bar value'</span>}
})
&lt;!--￼<span class="number">39</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-7-4-常用内置符号"><a href="#3-4-7-4-常用内置符号" class="headerlink" title="3.4.7.4 常用内置符号"></a>3.4.7.4 常用内置符号</h4><p>ECMAScript 6 引入了一批常用内置符号，用于暴露语言内部行为，开发者可以世界访问、重写或模拟这些行为。内置符号也就是全局函数 Symbol 的普通字符串属性，指向一个符号实例。</p>
<blockquote>
<p>在提到 ECMAScript 规范时，会引用符号在规范中的名称，前缀为 @@。比如，@@iterator 指的就是 Symbol.iterator。</p>
</blockquote>
<ul>
<li><p>Symbol.hasInstance：一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用。</p>
<ul>
<li><p>在 ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系</p>
<ul>
<li><pre><code class="js"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>{}
<span class="keyword">let</span> f = <span class="keyword">new</span> Foo();
<span class="comment">// 作用一致</span>
<span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo);    <span class="comment">// true</span>
<span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](f));    <span class="comment">// true</span>
&lt;!--￼<span class="number">40</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Symbol.isConcatSpreadable：一个布尔值，如果是 true，则意味着对象应该使用 Array.prototype.concat() 打平其数组元素。</p>
<ul>
<li><p>ES6 中的 Array.prototype.concat() 方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。下列覆盖 Symbol.isConcatSpreadable 的值可以修改这个行为：</p>
<ul>
<li>数组对象<ul>
<li>默认情况下会被打平到已有的数组。</li>
<li>false 或假值会导致整个对象被追加到数组末尾。</li>
</ul>
</li>
<li>类数组对象<ul>
<li>默认情况会被追加到数组末尾。</li>
<li>true 或真值会导致这个类数组对象被打平到数组实例。</li>
</ul>
</li>
<li>其他不是类数组对象的对象<ul>
<li>true 或真值将被忽略。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码演示上述情况：</p>
<ul>
<li><pre><code class="js"><span class="comment">// 数组对象</span>
<span class="keyword">let</span> initial = [<span class="string">'foo'</span>];
<span class="keyword">let</span> array = [<span class="string">'bar'</span>];

<span class="built_in">console</span>.log(array[<span class="built_in">Symbol</span>.isConcatSpreadable]);    <span class="comment">// undefined</span>
<span class="built_in">console</span>.log(initial.concat(array));    <span class="comment">// ['foo', 'bar']</span>
array.[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;    <span class="comment">// 改变内置符号</span>
<span class="built_in">console</span>.log(initial.concat(array));    <span class="comment">// ['foo', Array(1)]</span>
&lt;!--￼<span class="number">41</span>--&gt;</code></pre>
</li>
<li><pre><code class="js"><span class="comment">// 类数组对象</span>
<span class="keyword">let</span> initial = [<span class="string">'foo'</span>];
<span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'qux'</span>)

<span class="built_in">console</span>.log(otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);    <span class="comment">// undefined</span>
<span class="built_in">console</span>.log(initial.concat(otherObject));    <span class="comment">// ['foo', Set(1)]</span>
otherObject.[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;    <span class="comment">// 改变内置符号</span>
<span class="built_in">console</span>.log(initial.concat(otherObject));    <span class="comment">// ['foo']</span>
&lt;!--￼<span class="number">42</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Symbol.iterator：一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用</p>
<ul>
<li><p>这个由 Symbol.iterator 函数生成的对象可以隐式通过生成器函数返回：</p>
<ul>
<li><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>{
  <span class="keyword">constructor</span>(max) {
    <span class="keyword">this</span>.max = max;
    <span class="keyword">this</span>.Idx = <span class="number">0</span>;
  }
  <span class="comment">// 通过符号隐式修改 for-await-of 的默认行为</span>
  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.iterator](){
    <span class="keyword">while</span>(<span class="keyword">this</span>.Idx &lt; <span class="keyword">this</span>.max) {
      <span class="keyword">yield</span> <span class="keyword">this</span>.Idx++;
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>{
  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);
  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) {
    <span class="built_in">console</span>.log(x);
  }
}

count();
<span class="comment">// 0</span>
<span class="comment">// 1</span>
<span class="comment">// 2</span>
<span class="comment">// 3</span>
<span class="comment">// 4</span>
&lt;!--￼<span class="number">43</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Symbol.replace：一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace() 方法使用。</p>
<ul>
<li><p>String.prototype.replace() 方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。</p>
</li>
<li><p>Symbol.replace 函数接收两个参数，即调用 replace() 方法字符串实例和替换字符串。返回的值没有限制：</p>
<ul>
<li><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">FooReplacer</span> </span>{
  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.replace](target, replacement) {
    <span class="keyword">return</span> target.split(<span class="string">'foo'</span>).join(replacement);
  }
}
<span class="built_in">console</span>.log(<span class="string">'barfoobaz'</span>.replace(FooReplacer, <span class="string">'qux'</span>));    <span class="comment">// "barquxbaz"</span>

<span class="class"><span class="keyword">class</span> <span class="title">StringReplacer</span> </span>{
  <span class="keyword">constructor</span>(str) {
    <span class="keyword">this</span>.str = str;
  }
  [<span class="built_in">Symbol</span>.replace](target, replacement) {
    <span class="keyword">return</span> target.split(<span class="keyword">this</span>.str).join(replacement);
  }
}
<span class="built_in">console</span>.log(<span class="string">'barfoobaz'</span>.replace(<span class="keyword">new</span> StringReplacer(<span class="string">'foo'</span>), <span class="string">'qux'</span>));    <span class="comment">// "barquxbaz"</span>

&lt;!--￼<span class="number">44</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Symbol.species：一个函数值，该函数作为创建派生对象的构造函数。</p>
<ul>
<li><p>这个属性在内置类型中最常用，用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p>
<ul>
<li><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>{}

<span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>{
  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() {
    <span class="keyword">return</span> <span class="built_in">Array</span>;
  }
}

<span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();
<span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">// true</span>
<span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);    <span class="comment">// true</span>
bar = bar.concat(<span class="string">'bar'</span>);
<span class="built_in">console</span>.log(bar);    <span class="comment">// Bar(1) [ 'bar' ]</span>
<span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">// true</span>
<span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);    <span class="comment">// true</span>

<span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();
<span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">// true</span>
<span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);    <span class="comment">// true</span>
baz = baz.concat(<span class="string">'baz'</span>);
<span class="built_in">console</span>.log(baz);    <span class="comment">// [ 'bar' ]</span>
<span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">// true</span>
<span class="comment">// Symbol.species 内置重置</span>
<span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);    <span class="comment">// false</span>
&lt;!--￼<span class="number">45</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Symbol.toPrimitive：一个方法，该方法将对象转为相对应的原始值，由 ToPrimitive 抽象操作使用。</p>
<ul>
<li><p>根据提供给这个函数的参数(string、number 或 default)，可以控制返回的原始值：</p>
<ul>
<li><pre><code class="js"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{}
<span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>{
  <span class="keyword">constructor</span>() {
    <span class="keyword">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>{
      <span class="keyword">switch</span> (hint) {
        <span class="keyword">case</span> <span class="string">'number'</span>:
          <span class="keyword">return</span> <span class="number">3</span>;
        <span class="keyword">case</span> <span class="string">'string'</span>:
          <span class="keyword">return</span> <span class="string">'string bar'</span>;
        <span class="keyword">case</span> <span class="string">'default'</span>:
        <span class="keyword">default</span>:
          <span class="keyword">return</span> <span class="string">'default bar'</span>;
      }
    }
  }
}

<span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();
<span class="built_in">console</span>.log(<span class="number">3</span> + foo);    <span class="comment">// "3[object Object]"</span>
<span class="built_in">console</span>.log(<span class="number">3</span> - foo);    <span class="comment">// NaN</span>
<span class="built_in">console</span>.log(<span class="built_in">String</span>(foo));    <span class="comment">// "[object Object]"</span>

<span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();
<span class="built_in">console</span>.log(<span class="number">3</span> + bar);    <span class="comment">// "3default bar"</span>
<span class="built_in">console</span>.log(<span class="number">3</span> - bar);    <span class="comment">// 0</span>
<span class="built_in">console</span>.log(<span class="built_in">String</span>(bar));    <span class="comment">// "string bar"</span>
<span class="built_in">console</span>.log(<span class="built_in">Number</span>(bar));    <span class="comment">// 3</span>
&lt;!--￼<span class="number">46</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-8-Object-类型"><a href="#3-4-8-Object-类型" class="headerlink" title="3.4.8 Object 类型"></a>3.4.8 Object 类型</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>;	<span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>

<p>Object 是派生其他对象的基类，Object 类型的所有属性和方法在派生的对象上同样存在，每个 Object 实例都有如下属性和方法。</p>
<ul>
<li>constructor：用于创建当前对象的函数。</li>
<li>hasOwnProperty()：用于判断当前对象实例（不是原型）上是否有存在给定的属性。传入字符串参数。</li>
<li>isPrototypeof()：用于判断当前对象是否为另一个对象的原型。传入字符串参数。</li>
<li>propertyIsEnumerable()：用于判断给定的属性是否可以使用 for-in 语句枚举。传入字符串参数。</li>
<li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象对应的字符串、数值、布尔值表示。通常与 toString() 的返回值相同。</li>
</ul>
<blockquote>
<p>严格来说浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object。</p>
</blockquote>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h2><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。在应用给对象时，操作符通常会调用 valueof() 或 toString() 方法来取得可以计算的值</p>
<h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h3><ul>
<li><p>递增/递减操作符：直接照搬自 C 语言，且可作用于任何值，整数、字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则：</p>
<ul>
<li><p>字符串</p>
<ul>
<li>有效的数值形式，转换为数值再应用改变。变量类型从字符串变成数值。</li>
<li>无效的数值形式，将变量值设置为 NaN。变量类型从字符串变成数值。</li>
</ul>
</li>
<li><p>布尔值</p>
<ul>
<li>false，转换为 0 再应用改变。变量类型从布尔值变成数值。</li>
<li>true，转换为 1 再应用改变。变量类型从布尔值变成数值。</li>
</ul>
</li>
<li><p>浮点值：直接加 1 或减 1。</p>
</li>
<li><p>对象：调用其 valueof() 方法取得可以操作的值，对得到的值应用上述规则。如果是 NaN，则调用 toString() 并再次应用其他规则。变量类型从对象变为数值。</p>
</li>
<li><pre><code class="js"><span class="comment">// 演示上述规则</span>
<span class="keyword">let</span> s1 = <span class="string">"2"</span>;
<span class="keyword">let</span> s2 = <span class="string">"z"</span>;
<span class="keyword">let</span> b = <span class="literal">false</span>;
<span class="keyword">let</span> f = <span class="number">1.1</span>;
<span class="keyword">let</span> o = {
  valueof() {
    <span class="keyword">return</span> <span class="number">-1</span>;
  }
}

s1++;    <span class="comment">// 值变成数值 3</span>
s2++;    <span class="comment">// 值变成 NaN</span>
b++;    <span class="comment">// 值变成数值 1</span>
f--;    <span class="comment">// 值变成 0.10000000000000009（因为浮点数不精确）</span>
o--;    <span class="comment">// 值变成 -2</span>
&lt;!--￼<span class="number">48</span>--&gt;</code></pre>
</li>
<li><p>一元减由一个减号（-）表示，放在变量前头将其变成相应的负值</p>
<ul>
<li><pre><code class="js"><span class="comment">// 演示上述规则</span>
<span class="keyword">let</span> s1 = <span class="string">"01"</span>;
<span class="keyword">let</span> s2 = <span class="string">"1.1"</span>;
<span class="keyword">let</span> s3 = <span class="string">"z"</span>;
<span class="keyword">let</span> b = <span class="literal">false</span>;
<span class="keyword">let</span> f = <span class="number">1.1</span>;
<span class="keyword">let</span> o = {
  valueof() {
    <span class="keyword">return</span> <span class="number">-1</span>;
  }
}

s1 = -s1;    <span class="comment">// 值变成数值 -1</span>
s2 = -s2;    <span class="comment">// 值变成 -1.1</span>
s3 = -s3;    <span class="comment">// 值变成 NaN</span>
b = -b;    <span class="comment">// 值变成数值 0</span>
f = -f;    <span class="comment">// 值变成 -1.1</span>
o = -o;    <span class="comment">// 值变成 1</span>
&lt;!--￼<span class="number">49</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>尽管两者返回的结果一样，但位操作符的速度快得多。这是因为位操作是在数值的底层表示上完成的。</p>
</blockquote>
<h4 id="3-5-2-2-按位与"><a href="#3-5-2-2-按位与" class="headerlink" title="3.5.2.2 按位与"></a>3.5.2.2 按位与</h4><p>用 <strong>&amp;</strong> 表示，有两个操作数，若两个操作数二进制每一对应相同位上均为 1 则返回 1，否则返回 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;	<span class="comment">// 1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  25 = 0000 0000 0000 0000 0000 0000 0001 1001</span></span><br><span class="line"><span class="comment"> *   3 = 0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment"> * AND = 0000 0000 0000 0000 0000 0000 0000 0001</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">25</span> &amp; <span class="number">20</span>;	<span class="comment">// 16</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  25 = 0000 0000 0000 0000 0000 0000 0001 1001</span></span><br><span class="line"><span class="comment"> *  20 = 0000 0000 0000 0000 0000 0000 0001 0100</span></span><br><span class="line"><span class="comment"> * AND = 0000 0000 0000 0000 0000 0000 0001 0000</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-3-按位或"><a href="#3-5-2-3-按位或" class="headerlink" title="3.5.2.3 按位或"></a>3.5.2.3 按位或</h4><p>用 <strong>|</strong> 表示，有两个操作符，返回两个操作数二进制每一对应相同位上有 1 则返回 1，否则返回 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;	<span class="comment">// 27</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  25 = 0000 0000 0000 0000 0000 0000 0001 1001</span></span><br><span class="line"><span class="comment"> *   3 = 0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment"> * AND = 0000 0000 0000 0000 0000 0000 0001 1011</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-4-按位异或"><a href="#3-5-2-4-按位异或" class="headerlink" title="3.5.2.4 按位异或"></a>3.5.2.4 按位异或</h4><p>用 <strong>^</strong> 表示，有两个操作符，返回两个操作数二进制每一对应相同位上数值不同则返回 1，否则返回 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;	<span class="comment">// 26</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  25 = 0000 0000 0000 0000 0000 0000 0001 1001</span></span><br><span class="line"><span class="comment"> *   3 = 0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment"> * AND = 0000 0000 0000 0000 0000 0000 0001 1010</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-5-左移"><a href="#3-5-2-5-左移" class="headerlink" title="3.5.2.5 左移"></a>3.5.2.5 左移</h4><p>用 <strong>&lt;&lt;</strong> 表示，按照指定位数将数值的所有位向左移动，以 0 填充空位（保留 32 位中最左侧的符号位）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">2</span>;	<span class="comment">// 二进制 10</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;	<span class="comment">// 二进制 1000000 =&gt; 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左移会保留符号位</span></span><br><span class="line"><span class="keyword">let</span> oldValue2 = <span class="number">-2</span>;	<span class="comment">// 二进制 -10</span></span><br><span class="line"><span class="keyword">let</span> newValue2 = oldValue2 &lt;&lt; <span class="number">5</span>;	<span class="comment">// 二进制 -1000000 =&gt; -64</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-6-有符号右移"><a href="#3-5-2-6-有符号右移" class="headerlink" title="3.5.2.6 有符号右移"></a>3.5.2.6 有符号右移</h4><p>用 <strong>&gt;&gt;</strong> 表示，按照指定位数将数值的所有位向右移动，同时保留符号（正或负），（保留 32 位中最左侧的符号位）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">64</span>;	<span class="comment">// 二进制 1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;	<span class="comment">// 二进制 10 =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左移会保留符号位</span></span><br><span class="line"><span class="keyword">let</span> oldValue2 = <span class="number">-64</span>;	<span class="comment">// 二进制 -1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue2 = oldValue2 &gt;&gt; <span class="number">5</span>;	<span class="comment">// 二进制 -10 =&gt; -2</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-7-无符号右移"><a href="#3-5-2-7-无符号右移" class="headerlink" title="3.5.2.7 无符号右移"></a>3.5.2.7 无符号右移</h4><p>用 <strong>&gt;&gt;&gt;</strong> 表示，按照指定位数将数值的所有位向右移动，不保留符号，可表示的范围变大。</p>
<ul>
<li><p>正数：无符号右移与有符号右移结果相同。</p>
<ul>
<li><pre><code class="js"><span class="keyword">let</span> oldValue = <span class="number">64</span>;    <span class="comment">// 二进制 1000000</span>
<span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;    <span class="comment">// 二进制 10 =&gt; 2</span>
&lt;!--￼<span class="number">55</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h3><p>布尔操作符一共有 3 个：逻辑非、逻辑与和逻辑或。</p>
<ul>
<li><p><strong>!</strong> 逻辑非：该操作符首先将操作数转换为布尔值，然后再对其取反。</p>
<ul>
<li>对象，则返回 false。</li>
<li>空字符串，则返回 true。</li>
<li>非空字符串，则返回 false。</li>
<li>数值 0，则返回 true。</li>
<li>非 0 数值（包括 Infinity），则返回 false。</li>
<li>null，则返回 true。</li>
<li>NaN，则返回 true。</li>
<li>undefined，则返回 true。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">"blue"</span>);	<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">""</span>);	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">12345</span>);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>同时使用两个逻辑非 <strong>!!</strong> 相当于调用了转型函数 Boolean()。</p>
</blockquote>
</li>
<li><p><strong>&amp;&amp;</strong> 逻辑与：该操作符应用到两个值，且遵循如下规则：</p>
<ul>
<li><table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
<p>当第一个操作符为 true 时，将会作用到第二个操作符。反之不会作用到第二个操作符，因此可以当作一种<strong>短路操作符</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; undeclaredVariable);	<span class="comment">// 作用到未定义的 undeclaredVariable，这里会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">// 不会执行这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> found2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> result2 = (found2 &amp;&amp; undeclaredVariable);	<span class="comment">// 不会作用到未定义的 undeclaredVariable。</span></span><br><span class="line"><span class="built_in">console</span>.log(result2);	<span class="comment">// 会执行这一行，打印 false。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>||</strong> 逻辑或：该操作符应用到两个值，且遵循如下规则：</p>
<ul>
<li><table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
<p>与逻辑与类似，逻辑或也具有段路的特性。当第一个操作数求值为 true，第二个操作数就不会再被求值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found || undeclaredVariable);	<span class="comment">// 作用到未定义的 undeclaredVariable，这里会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result);	<span class="comment">// 不会执行这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> found2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result2 = (found2 &amp;&amp; undeclaredVariable);	<span class="comment">// 不会作用到未定义的 undeclaredVariable。</span></span><br><span class="line"><span class="built_in">console</span>.log(result2);	<span class="comment">// 会执行这一行，打印 false。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用这种行为，可以避免给变量赋值 null 或 undefined。</span></span><br><span class="line"><span class="keyword">let</span> myObject = preferredObject || backupObject	<span class="comment">// backupObject 可以被看作为备用的值。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6 加性操作符"></a>3.5.6 加性操作符</h3><p>加性操作符，即加法和减法操作符，在 ECMAScript 中，这两个操作符在后台会发生不同数据类型的转换。</p>
<ul>
<li><p><strong>+</strong> 加法操作符，用于求两个数的和，并应用如下转换规则：</p>
<ul>
<li>两个操作数均为数值<ul>
<li>任一操作数为 NaN，则返回 NaN。</li>
<li>Infinity 加 Infinity，则返回 Infinity。</li>
<li>-Infinity 加 -Infinity，则返回 -Infinity。</li>
<li>Infinity 加 -Infinity，则返回 NaN。</li>
<li>-0 加 +0，则返回 +0。</li>
</ul>
</li>
<li>两个操作数不均为数值<ul>
<li>均为字符串，则将第二个字符串拼接到第一个字符串后面。</li>
<li>任一操作数为字符串，则将另一个操作数转换为字符串，拼接起来。</li>
<li>任一操作数为其他数据类型，则调用它们的 toString() 方法，再拼接起来。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述常见错误：字符串与 num1 加法操作为字符串，再与 num2 加法操作仍为字符串。</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"The sum of 5 and 10 is "</span> + num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(message);	<span class="comment">// "The sum of 5 and 10 is 510"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决：优先相加数值，再拼接为字符串。</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"The sum of 5 and 10 is "</span> + (num1 + num2);</span><br><span class="line"><span class="built_in">console</span>.log(message);	<span class="comment">// "The sum of 5 and 10 is 15"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>-</strong> 减法操作符，用于求两个数的差，并应用如下转换规则：</p>
<ul>
<li><p>两个操作数均为数值</p>
<ul>
<li>任一操作数为 NaN，则返回 NaN。</li>
<li>Infinity 减 Infinity，则返回 NaN。</li>
<li>-Infinity 减 -Infinity，则返回 NaN。</li>
<li>Infinity 减 -Infinity，则返回 Infinity。</li>
<li>+0 减 -0，则返回 -0。</li>
<li>-0 减 -0，则返回 +0。</li>
</ul>
</li>
<li><p>任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number() 将其转换为数值，再根据应用上边规则。</p>
</li>
<li><p>任一操作数是对象</p>
<ul>
<li>有valueOf()方法，则调用其 valueOf() 方法取得表示它的数值。</li>
<li>无valueOf()方法，则调用其 toString() 方法，然后再将得到的字符串转换为数值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示上述规则</span></span><br><span class="line"><span class="keyword">let</span> res1 = <span class="number">5</span> - <span class="literal">true</span>;	<span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> res2 = <span class="literal">NaN</span> - <span class="number">1</span>; <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">let</span> res3 = <span class="number">5</span> - <span class="number">3</span>;	<span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> res4 = <span class="number">5</span> - <span class="string">""</span>;	<span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> res5 = <span class="number">5</span> - <span class="string">"2"</span>;	<span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> res6 = <span class="number">5</span> - <span class="literal">null</span>;	<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7 关系操作符"></a>3.5.7 关系操作符</h3><p>关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=），返回布尔值。应用到不同数据类型时也会发生类型转换和其他行为，如下规则：</p>
<ul>
<li>都是数值，则执行数值比较。</li>
<li>都是字符串，则逐个比较字符串中对应字符的编码。</li>
<li>任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li>
<li>有任一操作数是布尔值，则将其转换为数值再执行比较。</li>
<li>任一操作数是对象<ul>
<li>若有 valueOf() 方法，取得结果后根据前面规则执行比较。</li>
<li>若无 valueOf() 方法，则调用 toString() 方法，再根据前面规则执行比较。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见关系操作符错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 大写字母编码小于小写字母编码</span></span><br><span class="line"><span class="keyword">let</span> resultError1 = <span class="string">"Brick"</span> &lt; <span class="string">"alphabet"</span>;	<span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> resultGreat1 = <span class="string">"Brick"</span>.toLowerCase() &lt; <span class="string">"alphabet"</span>.toLowerCase();	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数值字符串，字符编码不一致。</span></span><br><span class="line"><span class="keyword">let</span> resultError2 = <span class="string">"23"</span> &lt; <span class="string">"3"</span>;	<span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> resultGreat2 = <span class="string">"23"</span> &lt; <span class="number">3</span>;	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 若关系操作符涉及到返回结果为 NaN，则均返回 false。</span></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>;	<span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span>;	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8 相等操作符"></a>3.5.8 相等操作符</h3><p>ECMAScript 提供了两组操作符。第一组是<strong>等于</strong>和<strong>不等于</strong>，在比较之前执行转换。第二组是<strong>全等</strong>和<strong>不全等</strong>，在比较之前不执行转换。</p>
<h4 id="3-5-8-1-等于和不等于"><a href="#3-5-8-1-等于和不等于" class="headerlink" title="3.5.8.1 等于和不等于"></a>3.5.8.1 等于和不等于</h4><p>等于操作符用（==）表示，不等于操作符用（!=）表示。这两个操作符都会先进行强制类型转换再确定操作数是否相等。</p>
<p>遵循如下转换规则：</p>
<ul>
<li>任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</li>
<li>一个操作数是字符串，另一个是数值，则将字符串转换为数值，再比较是否相等。</li>
<li>一个操作数是对象，另一个不是，则调用对象的 valueOf() 取得原始值，再根据前面规则进行比较。</li>
</ul>
<p>遵循如下比较规则：</p>
<ul>
<li>null 和 undefined 相等。</li>
<li>null 和 undefined 不能转换为其他类型的值再进行比较。</li>
<li>任一操作数为 NaN，则均为不相等。按照规则， NaN 不等于 NaN。</li>
<li>两个操作符均为对象，则比较是否为同一对象，是则相等，反之则不相等。</li>
</ul>
<blockquote>
<p>下表列举一些特殊情况及比较结果</p>
</blockquote>
<table>
<thead>
<tr>
<th>表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>null == undefined</td>
<td>true</td>
</tr>
<tr>
<td>“NaN” == NaN</td>
<td>false</td>
</tr>
<tr>
<td>5 == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN != NaN</td>
<td>true</td>
</tr>
<tr>
<td>false == 0</td>
<td>true</td>
</tr>
<tr>
<td>true == 1</td>
<td>true</td>
</tr>
<tr>
<td>true == 2</td>
<td>false</td>
</tr>
<tr>
<td>undefined == 0</td>
<td>false</td>
</tr>
<tr>
<td>null == 0</td>
<td>false</td>
</tr>
<tr>
<td>“5” == 5</td>
<td>true</td>
</tr>
</tbody></table>
<h4 id="3-5-8-2-全等和不全等"><a href="#3-5-8-2-全等和不全等" class="headerlink" title="3.5.8.2 全等和不全等"></a>3.5.8.2 全等和不全等</h4><p>全等操作符用（===）表示，不全等操作符用（!==）表示。这两个操作符都不会进行强制类型转换，便确定操作数是否相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = (<span class="string">"55"</span> == <span class="number">55</span>);	<span class="comment">// true，转换后相等。</span></span><br><span class="line"><span class="keyword">let</span> res2 = (<span class="string">"55"</span> === <span class="number">55</span>);	<span class="comment">// false，数据类型不同。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res3 = (<span class="string">"55"</span> != <span class="number">55</span>);	<span class="comment">// false，转换后相等。</span></span><br><span class="line"><span class="keyword">let</span> res4 = (<span class="string">"55"</span> !== <span class="number">55</span>);	<span class="comment">// true，数据类型不同。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res5 = (<span class="literal">null</span> == <span class="literal">undefined</span>);	<span class="comment">// true，两个值类似。</span></span><br><span class="line"><span class="keyword">let</span> res6 = (<span class="literal">null</span> !== <span class="literal">undefined</span>);	<span class="comment">// false，数据类型不同。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。有助于在代码中保持数据类型的完整性。</p>
</blockquote>
<h3 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9 条件操作符"></a>3.5.9 条件操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean_expression 为 true 返回 true_value 赋予 variable，反之亦然。</span></span><br><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-11-逗号操作符"><a href="#3-5-11-逗号操作符" class="headerlink" title="3.5.11 逗号操作符"></a>3.5.11 逗号操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逗号操作符可以用来在一条语句中执行多个操作。</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用逗号操作符在赋值多个值时，最终会返回表达式中对后一个值。</span></span><br><span class="line"><span class="keyword">let</span> num2 = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>);	<span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h2><p>ECMA-262 描述了一些语句（也称为流控制语句），而 ECMAScript 中的大部分语法都体现在语句中。</p>
<h3 id="3-6-2-do-while-语句"><a href="#3-6-2-do-while-语句" class="headerlink" title="3.6.2 do-while 语句"></a>3.6.2 do-while 语句</h3><p>do-while 语句是一种后测试循环语句，用于循环体内代码在退出前至少要执行一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、4、6、8、10</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-5-for-in-语句"><a href="#3-6-5-for-in-语句" class="headerlink" title="3.6.5 for-in 语句"></a>3.6.5 for-in 语句</h3><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性。如果要迭代的变量是 null 或 undefined，则不执行循环体。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"lindada"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  job: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> obj) &#123;	<span class="comment">// const 确保这个局部变量不被修改。</span></span><br><span class="line">  <span class="built_in">console</span>.log(propName)	<span class="comment">// 返回的属性顺序不一定一致。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name、age、job</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-6-for-of-语句"><a href="#3-6-6-for-of-语句" class="headerlink" title="3.6.6 for-of 语句"></a>3.6.6 for-of 语句</h3><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、4、6、8</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>for-of 循环会按照可迭代对象的 next() 方法产生值的顺序迭代元素，关于可迭代对象，第 7 章详细介绍。</p>
<p>ES2018 对 for-of 语句进行了扩展，增加了 for-await-of 循环，以支持生成期约（promise）的异步可迭代对象。</p>
</blockquote>
<h3 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7 标签语句"></a>3.6.7 标签语句</h3><p>标签语句用于给语句加标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start 是 for 语句的标签，可以通过 break 或 continue 语句引用</span></span><br><span class="line"><span class="comment">// 在嵌套循环中十分有用。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-8-break-和-continue-语句"><a href="#3-6-8-break-和-continue-语句" class="headerlink" title="3.6.8 break 和 continue 语句"></a>3.6.8 break 和 continue 语句</h3><p>为执行循环代码提供了更严格的控制手段。break 语句用于立即跳出循环，强制执行循环后的下一语句。continue 语句也用于立即跳出循环，但会再次从循环顶部开始执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break 和 continue 与标签语句来控制外部嵌套循环的语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">0</span>;</span><br><span class="line">outermost1:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost1;</span><br><span class="line">    &#125;</span><br><span class="line">    num1++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num1);	<span class="comment">// 55</span></span><br><span class="line"><span class="comment">// 当 i 和 j 均为 5 时，break 跳出结束外部标签 outermost 循环语句，结束循环。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">0</span>;</span><br><span class="line">outermost2:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost2;</span><br><span class="line">    &#125;</span><br><span class="line">    num2++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num2);	<span class="comment">// 95</span></span><br><span class="line"><span class="comment">// 当 i 和 j 均为 5 时，continue 跳出结束外部标签 outermost 循环语句，进行下一次循环。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-10-switch-语句"><a href="#3-6-10-switch-语句" class="headerlink" title="3.6.10 switch 语句"></a>3.6.10 switch 语句</h3><p>switch 语句是与 if 语句紧密相关的一种流控制语句，如下两个语句等效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">if</span> (i === <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"25"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">35</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"35"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Other"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"25"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"35"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Other"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 case 条件后面都需加上 break 语句，如果确实需要连续匹配几个条件，那么推荐写注释表明情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">    <span class="comment">/*跳过*/</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"25 or 35"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    conosle.log(Other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ECMAScript 为 switch 语句赋予了一些独有的特性，可用于所有数据类型（不限于数值），case 条件的值不仅为常量，可以是变量或表达式。</p>
<p>switch 语句在比较每个条件的值时，会使用全等操作符，因此不会强制转换数据类型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Less than 0"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Between 0 and 10"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"More than 20"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h2><p>ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。（第 10 章会更详细地介绍函数。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name + <span class="string">", "</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过函数名来调用函数</span></span><br><span class="line">sayHi(<span class="string">"lindada"</span>, <span class="string">"how are you today?"</span>);	<span class="comment">// "Hello lindada, how are you today?"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>除了 return 语句之外没有任何特殊声明表明该函数有返回值，如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = sum(<span class="number">5</span>, <span class="number">10</span>);	<span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只要碰到 return 语句，函数就会立即停止执行并退出。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"can't do it!"</span>);	<span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>return 语句也可以不带返回值。这时候，函数会立即停止执行并返回 undefined，这种用法最常用于提前终止函数执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;	<span class="comment">// 终止返回 undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name + <span class="string">", "</span> + message);	<span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>严格模式对函数也有一些限制，若违反如下规则，则导致语法错误：</p>
<ul>
<li>函数不能以 eval 或 arguments 座位名称；</li>
<li>函数的参数不能叫做  eval 或 arguments；</li>
<li>两个函数的参数不能叫同一个名称。</li>
</ul>
</blockquote>
<h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h2><p>JavaScript 的核心语言特性在 ECMA-262 中以伪语言 ECMAScript 的形式来定义。理解 ECMAScript 及其复杂的细节是完全理解浏览器中 JavaScript 的关键。下面总结一下 ECMAScript 中的基本元素。</p>
<ul>
<li>ECMAScript中的基本数据类型<ul>
<li>ES6 之前<ul>
<li>Undefined、Null、Boolean、Number、String</li>
</ul>
</li>
<li>ES6 之后 ES10 之前<ul>
<li>新增 Symbol</li>
</ul>
</li>
<li>ES10 之后<ul>
<li>新增 BigInt</li>
</ul>
</li>
</ul>
</li>
<li>ECMAScript 不区分整数和浮点数，只有 Number 一种数值数据类型。</li>
<li>Object 是一种复杂数据类型，它是这门语言中所有对象的基类。</li>
<li>严格模式为这门语言中某些容易出错的部分施加了限制。</li>
<li>ECMAScript 提供了 C 语言和类 C 语言中常见的很多基本操作符。</li>
<li>流控制语句大多是从其他语言中借鉴惹来的。</li>
</ul>
<p>ECMAScript 中的函数特点</p>
<ul>
<li>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。</li>
<li>不指定返回值的函数实际上会返回特殊值 undefined。</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        
                                            <!--MOB SHARE BEGIN-->
<a><div class="-mob-share-open article-share-link">分享</div></a>
<div class="-mob-share-ui" style="display: none; display: flex; align-items: center; align-content: center;">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
    </ul>
    <div style="height: 100%; width: 100%">
        <div class="-mob-share-close" style="position:relative; margin: -26em auto; width: 80px; height: 40px; font-size: 14px; color: #fff; background-color: #4593e9; border-radius: 15px;">取消</div>
    </div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="/lindada-blog/js/mob-share.js"></script>
<!--MOB SHARE END-->

                                        
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/lindada-blog/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/" rel="tag">红宝书</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/lindada-blog/2021/04/07/Canvas%E5%8A%A8%E7%94%BB%E5%B0%8Fdemo%EF%BC%88%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            Canvas动画小demo（从零到一）
          
        </div>
      </a>
    
    
      <a href="/lindada-blog/2021/02/28/%EF%BC%88%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0%EF%BC%89%E6%88%91%E4%B8%80%E5%AD%97%E4%B8%80%E8%A1%8C%E5%9C%B0%E9%87%8D%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">（第一二章）我一字一行地重读红宝书</div>
      </a>
    
  </nav>


            

                
                    
    <div class="vcomments" id="vcomments"></div>
    
<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

        <script>
            new Valine({
                el: '#vcomments',
                appId: 'vtOOBRQNx6g17peggpfzBROa-9Nh9j0Va',
                appKey: 'Q1DgaTCfUeYjMOqoTAH8TX9M',
                notify: 'false',
                verify: 'true',
                avatar: 'mp',
                pageSize: '20',
                placeholder: '✨悄悄地对小屋说...'
            })
        </script>
        
                        
                            

</article>

</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li>访客数 <i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li>阅读量 <i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>

    </div>
    <ul class="list-inline">
      <li>&copy; 2021 大大的小屋</li> |
      <li> Gitee主页 by <a href="https://gitee.com/lin_daren" target="_blank">林大大的Gitee</a></li> |
      <li> Wechat by <span class="footer-title">dadaLin_0809</span></li>
      <li> Email by <span class="footer-title">809751956@qq.com</span></li> |
    </ul>
  </div>
</footer>

<style>
    .footer-title {
        color: darkcyan;
        font-weight: bold;
    }
</style>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/lindada-blog/"><img src="/lindada-blog/images/star.svg" alt="大大的小屋"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/lindada-blog/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/lindada-blog/js/jquery-2.0.3.min.js"></script>


<script src="/lindada-blog/js/jquery.justifiedGallery.min.js"></script>


<script src="/lindada-blog/js/lazyload.min.js"></script>


<script src="/lindada-blog/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/lindada-blog/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/lindada-blog/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/lindada-blog/js/ocean.js"></script>


<script src="/lindada-blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/lindada-blog/live2dw/assets/assets/shizuku.model.json"},"display":{"position":"left","width":180,"height":360,"top":"-40px","right":"25px"},"mobile":{"show":true}});</script></body>
</html>
