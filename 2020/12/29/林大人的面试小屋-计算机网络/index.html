<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    林大人的面试小屋-计算机网络 |
    
    大大的小屋</title>
  
    <link rel="shortcut icon" href="/lindada-blog/fav.svg">
  
  
<link rel="stylesheet" href="/lindada-blog/css/style.css">

  
    
<link rel="stylesheet" href="/lindada-blog/fancybox/jquery.fancybox.min.css">

  
  
<script src="/lindada-blog/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/lindada-blog/atom.xml" title="大大的小屋" type="application/atom+xml">
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-林大人的面试小屋-计算机网络" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      林大人的面试小屋-计算机网络
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/lindada-blog/2020/12/29/%E6%9E%97%E5%A4%A7%E4%BA%BA%E7%9A%84%E9%9D%A2%E8%AF%95%E5%B0%8F%E5%B1%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2020-12-29T08:31:16.000Z" itemprop="datePublished">2020-12-29</time>
</a>
                            
                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <img src="/lindada-blog/2020/12/29/%E6%9E%97%E5%A4%A7%E4%BA%BA%E7%9A%84%E9%9D%A2%E8%AF%95%E5%B0%8F%E5%B1%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.png" class>  
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总结计算机网络<br>整理给有需要的小伙伴们 ✨</p>
<a id="more"></a>

<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-七层协议："><a href="#1-七层协议：" class="headerlink" title="1. 七层协议："></a>1. 七层协议：</h2><ol>
<li>应用层：HTTP</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层：TCP</li>
<li>网络层：IP传输</li>
<li>数据链路层</li>
<li>物理层。 </li>
</ol>
<h2 id="2-DNS解析"><a href="#2-DNS解析" class="headerlink" title="2. DNS解析"></a>2. DNS解析</h2><p> DNS解析的就是通过域名系统查询对应的IP。</p>
<p>具体过程</p>
<ol>
<li>首先当用户在url中输入一个网址后，操作系统首先会在本地缓存中查询，若本地缓存中查询到就向用户返回对应的IP</li>
<li>若没有则去系统配置的DNS服务器中查询，本地服务器向根域名服务器中查询</li>
<li>根域名服务器返回顶级域名服务器的ip地址的列表</li>
<li>本地服务器向顶级域名服务器发送请求</li>
<li>顶级域名服务器返回权威域名服务器的IP地址列表</li>
<li>然后本地服务器再向权威域名服务器发送请求</li>
<li>最后权威域名服务器返回一个与主机名对应的IP地址列表。 </li>
</ol>
<p>递归查询指的是当我们发起一次请求后，域名服务器代为向下一级服务器发起请求，最终返回一个结果给我们，用户只需发起一次请求即可。</p>
<p>迭代查询指的是用户发起一次请求之后，域名服务器返回单次查询的结果，下一次域名服务器还需要用户自己发起请求查询，迭代查询需要发起多次查询才会返回最终的查询结果。 </p>
<p>那么我们向<strong>本地DNS服务器发起请求的方式就是递归请求</strong>，因为我们只需发起一次请求，等待本地服务器返回最终结果给我们。而本地DNS服务器向域名服务器发起请求属于迭代请求，需要本地服务器一次次的向不同级域名服务器发起请求才会返回最终的结果。 </p>
<h2 id="3-前后端如何通信"><a href="#3-前后端如何通信" class="headerlink" title="3. 前后端如何通信"></a>3. 前后端如何通信</h2><p> Ajax、WebSocket、CORS </p>
<p> WebSocket指的是允许服务器主动向客户端推送信息，websocket是一个全双工协议，就是通信双方是平等的，可以相互发送信息。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，进行双向数据传输。 </p>
<p> Ajax的readystate值：0：未初始化，即请求还没初始化；1：正在加载，即已建立服务器连接；2：加载成功，即请求已接受；3：正在交互，即正在处理请求；4：完成，即请求已完成且响应已准备好。 </p>
<p> Ajax会自动带上同源的cookies，跨域时不会带上cookies。 </p>
<p> 若想在跨域时携带cookies，则需要在<a href>前端</a>设置withCredentials为true，同时在服务器端header设置Across-Control-Allow-Credentials为true。 </p>
<h2 id="4-CDN"><a href="#4-CDN" class="headerlink" title="4. CDN"></a>4. CDN</h2><p> 内容分发网络，它是构建在现有互联网基础之上的一层智能虚拟网络，它通过在不同地理位置建立节点服务器，对源网站资源进行不同节点的缓存，让用户在访问资源时可以就近获取所需的资源内容。CDN服务可以大大缩减用户访问服务器所需时间，提高了访问效率和响应速度与网站的可用性，解决了网络带宽小，用户访问量大，网点分布不均等问题。 </p>
<h2 id="5-Cookies、Session"><a href="#5-Cookies、Session" class="headerlink" title="5. Cookies、Session"></a>5. Cookies、Session</h2><p> 应用场景：当我们第一次登陆了某个网站之后验证了身份信息，之后再次登陆时不需要验证可以直接登陆，这时候就用到了cookies。例如场景为购物车时，添加了商品之后<a href>客户端</a>处就可以知道添加了哪些商品，而服务器如何判别呢，所以也需要储存一些信息就用到了session。 </p>
<h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><p> 服务器通过设置set-cookies这个响应头，将cookies信息返回给浏览器，浏览器将响应头中的cookies信息保存在本地中，当下次向服务器发送http请求时，浏览器会自动保存这些cookies信息到请求头中。 </p>
<p> 通过cookies服务器就会识别浏览器，从而保证返回的数据是这个用户的。 </p>
<h5 id="cookies属性"><a href="#cookies属性" class="headerlink" title="cookies属性"></a>cookies属性</h5><p> max-age：过期时间有多长，默认在浏览器关闭时失效。 </p>
<p> expires：设置过期时间。 </p>
<p> secure：表示cookies只会在https的时候才会发送。 </p>
<p> httponly：表示js脚本不能获取cookies，防止攻击者盗用用户cookies </p>
<p> domain：表示该cookies对于哪个域是有效的。 </p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p> 存放在服务器的一种用来存放用户数据的结构。浏览器第一次发送请求时服务器自动生成了hashtable和sessionid来唯一表示这个hash表，并将sessionid存放在cookies中通过响应发送到浏览器，浏览器第二次请求时会将前一次服务器响应的sessionid随着cookies发送到服务器端，服务器从请求中提取sessionid，并和保存的所有sessionid进行对比，找到这个用户所对应的hash表。 </p>
<p> 当用户在应用程序的不同web页面间跳转时，存储在session对象中的变量不会丢失而是在整个用户会话中一直存在下去。并且session依赖于cookies，因为sessionid是保存在cookie中的。 </p>
<h3 id="session和cookies的区别"><a href="#session和cookies的区别" class="headerlink" title="session和cookies的区别"></a>session和cookies的区别</h3><ol>
<li>cookies是保存在客户端的，而session是保存在服务器端的。 </li>
<li>cookies因为在客户端保存，所以容易被窃取，为了保证安全，应将数据存放在session中。 </li>
<li>session因为保存在服务器端，因此会消耗大量服务器资源，而cookies在每次http请求中都会带上，因此影响网络性能。 </li>
</ol>
<h2 id="6-HTTP"><a href="#6-HTTP" class="headerlink" title="6. HTTP"></a>6. HTTP</h2><p>HTTP是超文本传输协议，它是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。 </p>
<p>它是无连接的无状态的。 </p>
<h3 id="请求报文：请求头有哪些？"><a href="#请求报文：请求头有哪些？" class="headerlink" title="请求报文：请求头有哪些？"></a>请求报文：请求头有哪些？</h3><ol>
<li>Accept：用户代理可处理的媒体类型； </li>
<li>Accept-Charset：优先的字符集 </li>
<li>Accept-Encoding：优先的内容编码 </li>
<li>Accept-Language：优先的语言 </li>
<li>if-modified-since：比较资源的更新时间 </li>
<li>if-none-match：比较实体标记 </li>
<li>referer：对请求中uri的原始获取方 </li>
<li>user-agent：http客户端程序的信息 </li>
<li>Content-Type：实体主体的媒体类型 </li>
</ol>
<h3 id="响应报文：响应头部有哪些？"><a href="#响应报文：响应头部有哪些？" class="headerlink" title="响应报文：响应头部有哪些？"></a>响应报文：响应头部有哪些？</h3><ol>
<li>Age：推算资源创建经过时间 </li>
<li>ETag：资源的匹配信息 </li>
<li>Location：让客户端重定向至指定URI </li>
<li>Last-modified：资源的最后修改日期时间 </li>
<li>Expires：实体主体过期的日期时间 </li>
<li>Content-Type：实体主体的媒体类型 </li>
</ol>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p> 100：表示服务器端接收到请求，可继续发送请求 </p>
<p> 101：切换协议，一般是将http协议切换到更高版本； </p>
<p> 200：请求成功 OK </p>
<p> 201：服务器端接收到请求，并成功创建了一个新资源； </p>
<p> 204：请求成功，但响应报文中不含实体的主体部分； </p>
<p> 205：请求成功，但响应报文中不含实体的主体部分，但与204的区别是要求客户端重置内容； </p>
<p> 206：进行范围请求，成功处理了部分内容； </p>
<p> 300：多种选择，请求的资源可包括多个位置，服务器端返回资源特征和响应的地址列表。 </p>
<p> 301：永久重定向； </p>
<p> 302：临时重定向； </p>
<p> 303：表示资源存在着另一个URL，应使用GET方法获取资源； </p>
<p> 304：未作修改的，浏览器端自上次请求以来，请求的条件和内容并未发生改变，服务器端返回304状态码，成为if-modified-since的http标头。 </p>
<p> 307：临时重定向，和302含义类似，但期望客户端保持请求方法不变向新的地址发出请求。 </p>
<p> 400：请求报文存在语法错误； </p>
<p> 401：表示发送的请求需要通过http认证的身份验证信息； </p>
<p> 403：对于请求资源的访问，被服务器拒绝； </p>
<p> 404：在服务器上没有找到请求的资源； </p>
<p> 500：服务器端在执行请求时发生了错误</p>
<p> 501：表示服务器不支持请求所需的某个功能； </p>
<p> 503：表示服务器在超负荷或正在停机维护，无法处理请求。 </p>
<h3 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h3><ol>
<li>get主要是向服务器端请求获取数据，不会对服务器端数据进行修改。而post主要用于提交数据，会对数据有所更新。 </li>
<li>get在浏览器回退时是无害的，post需要重新提交。 </li>
<li>get请求可以缓存，因为它并不更新数据库，因为可以缓存到本地中下次请求时直接从缓存中获取，而post不能缓存。 </li>
<li>post相对于get来说较为安全，因为get请求包含在url中，会被浏览器保存记录且易于暴露窃取。而post较为安全。 </li>
<li>因为url有长度限制，因此get的传递参数内容有长度限制，而post无长度限制，post可以通过req.body来传输比get更多的数据。 </li>
<li>post请求发送两次，第一次先发送header，服务器端响应100表示继续发送，第二次再发送data，服务器响应200 ok。而get请求一次。 </li>
<li>post支持更多的编码类型而不会对数据类型限制。 </li>
</ol>
<h3 id="HTTP-CSP内容安全策略"><a href="#HTTP-CSP内容安全策略" class="headerlink" title="HTTP CSP内容安全策略"></a>HTTP CSP内容安全策略</h3><p>内容安全策略主要是限制资源获取，并报告资源获取越权。 </p>
<p>可以再http头部设置Content-Security-Policy: default-src http: https：表示只允许通过http、https的方式加载资源； </p>
<p>还可以通过meta标签内设置http-equiv=’Content-Security-Policy’； </p>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>相比于http1来说大幅度提高了web的性能。并且采用二进制的格式传输，取代了http1的文本格式，二进制格式解析更高效。多路复用替代了http1中的阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。 </p>
<p>二进制传输： </p>
<p>HTTP2中的加强性能的核心点在于此，大幅度提高了web性能。采用二进制格式传输，取代了http1中的文本格式，二进制格式解析更高效。 </p>
<p>多路复用： </p>
<ol>
<li>在http1中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接限制。 </li>
<li>在http2中，首先同域名下所有通信都在单个连接上完成，消除了因多个TCP连接而带来的延迟和内存消耗。单个连接上可以并行交错的请求和响应，之间互不干扰。 </li>
<li>在HTTP2中有两个非常重要的概念，分别是帧和流，帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用就是在一个TCP连接中可以存在多个流，也就是可以发送多个请求，通过对帧的标识知道属于哪个请求，通过这个技术，可以避免http旧版本中的队头阻塞问题，极大的提高传输性 </li>
</ol>
<p>Header压缩： </p>
<p>在http1中，我们使用文本的形式传输header，在header携带cookies的情况下，可能每次都要重复传输几百到几千的字节。 </p>
<p>而在http2中，使用header压缩可以减少每次传输的大小，在两端维护了索引表，用于记录出现过的header，在之后的传输过程中就可以传输已经记录过的header键名，对端收到数据后就可以通过键名找到对应的值。 </p>
<p>服务器端Push：</p>
<p>在http2中，服务器可以再客户端某个请求之后主要推送其他资源。 </p>
<p>例如某些资源客户端是一定会请求的，这时就可以采取服务器端push技术，提前给客户端推送必要的资源，这样就可以节省一些请求时的开销减少一些延迟时间。</p>
<h2 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h2><p> http默认端口为80，对于传输采用不加密的方式，而https默认端口为443，对于传输的数据进行加密传输。 </p>
<h3 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h3><p> 又称私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据，对称加密的特点是算法公开，加密和解密的速度快，适合于大数据量进行加密。加密过程中的私钥与解密过程中的私钥是同一个密钥，因此成为对称加密，由于对称加密的算法公开，因此密钥一旦被泄漏，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。 </p>
<h3 id="非对称加密："><a href="#非对称加密：" class="headerlink" title="非对称加密："></a>非对称加密：</h3><p> 又称为公钥加密，与对称加密相比，安全性更高，非对称加密使用一对密钥，分别为公钥和私钥，且二者成对出现，私钥被自己保存，不能对外泄露，公钥指的是公共的密钥，任何人都可以获取。用公钥和密钥中的任何一个进行加密，用另一个进行解密。缺点是加密和解密的时间长，速度慢，只适合对少量数据进行加密。 </p>
<h3 id="HTTPS通信过程："><a href="#HTTPS通信过程：" class="headerlink" title="HTTPS通信过程："></a>HTTPS通信过程：</h3><p> HTTPS协议=HTTP协议+SSL/TLS协议，HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。具体是数据是利用对称加密进行传输，而对称加密的过程需要客户端的一个密钥，为了确保能把密钥安全传输到服务器端，采用非对称加密的方式去对该密钥再进行加密传输，总的来说，就是对数据进行对称加密，而对称加密所需的密钥通过非对称加密传输。 </p>
<h3 id="HTTPS请求过程：共四次握手"><a href="#HTTPS请求过程：共四次握手" class="headerlink" title="HTTPS请求过程：共四次握手"></a>HTTPS请求过程：共四次握手</h3><ol>
<li>首先用户向服务器端发送HTTPS请求，请求到服务器端的443端口上。 </li>
<li>服务器端有一对密钥，分别为公钥和私钥，私钥由服务器端自身保存并且不可泄露，公钥可以传递给任何人。 </li>
<li>服务器端向客户端发送公钥 </li>
<li>客户端接收到公钥之后，首先检测公钥是否合法，如果不合法则此次HTTPS传输无效，如果公钥合格，就会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们成它为客户端密钥，主要是为了和服务器端上的密钥进行区分，然后用服务器端传递过来的公钥对这个客户端密钥进行非对称加密，这样客户端密钥就变成了密文，然后再传递给服务器端。 </li>
<li>服务器端接收到密文之后，用私钥对其进行非对称加密，获取到明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，然后将加密后的密文再传递给客户端。 </li>
<li>客户端接收到服务器端传递过来的密文，用客户端密钥进行对称解密，得到服务器端传递过来的数据。 </li>
</ol>
<h2 id="8-Restful"><a href="#8-Restful" class="headerlink" title="8. Restful"></a>8. Restful</h2><p> 表述性状态转移，一组架构约束条件和原则。如果一个架构符合Rest的约束条件和原则，我们就称它为Restful架构。 </p>
<p> 基本概念：在restful中，一切的内容都被认为是一种资源。每个资源都由URI唯一标识。使用统一的接口处理资源请求（POST/PUT/GET/DELETE/HEAD）。无状态（每次请求之前是无关联，没有session） </p>
<p> HEAD：主要用于确认URL的有效性以及资源更新的日期时间等。 </p>
<p> PATCH：新引入的，对PUT方法的补充，用来对已知资源进行局部更新。</p>
<h2 id="9-资源表述"><a href="#9-资源表述" class="headerlink" title="9. 资源表述"></a>9. 资源表述</h2><p> 客户端获取的是资源的表述，资源在外界的具体呈现，可以有多种表述形式，在客户端和服务器端之间传送的也是资源的表述，而不是资源本身。文本资源可以采用html、xml、json等格式，图片可以采用jpg、png展现出来。 </p>
<p> 资源的表述包括数据和描述数据的元数据，例如content-type就是元数据属性。 </p>
<p> 客户端如何知道服务器端提供哪种表述形式呢？ </p>
<p> 可以通过HTTP内容协商，客户端可以通过在请求头中通过Accept请求一种特定格式的表述，服务器端则通过Content-Type告诉客户端资源的表述形式。</p>
<h2 id="10-TCP"><a href="#10-TCP" class="headerlink" title="10. TCP"></a>10. TCP</h2><p> TCP又叫传输控制协议，是面向连接的，可靠的，基于字节流的传输协议。在基于TCP进行通信时，通信双方需要先建立一个TCP连接，<strong>建立连接需要经过三次握手，断开连接需要经过四次握手</strong>。 </p>
<p> TCP头部一些字段： </p>
<ul>
<li>序列号（seq）：这个序号保证了TCP传输的报文是有序的，对端可以通过序号来拼接报文字段。 </li>
<li>确认号：这个序号表示数据接接收端期望接收的下一个字节的编号是多少， </li>
<li>窗口大小（Window Size）：表示还能接收多少字节的数据，用于流量控制。 </li>
<li>标识符： <ul>
<li>ACK=1：该字段为表示确认号字段是有效的，此外TCP还规定在连接建立后传送的所有报文必须将ACK设为1. </li>
<li>SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文，当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。 </li>
<li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。 </li>
</ul>
</li>
</ul>
<h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><ol>
<li>第一次握手：SYN=1，seq=x。客户端向服务器端发起连接请求报文段，该报文中包含自身的数据通讯初始序号，请求发送后，客户端进入SYN-SENT状态。 </li>
<li>第二次握手：SYN=1，ACK=1，确认序号=x+1，seq=y。服务器端收到连接请求之后，如果同意连接则会发送一个应答，该应答中也会包含自身的数据通讯初始号，发送完成后便进入SYN-RECEIVED状态。 </li>
<li>第三次握手：ACK=1，确认序号=y+1，seq=x+1。客户端收到连接同意的应答后，还要向服务器端发送一个确认报文，客户端发送完这个报文段后便进入到ESTABLISHED状态，服务器端收到这个应答后也进入ESTABLISHED状态，此时连接建立成功。 </li>
</ol>
<h4 id="为什么不用两次握手？"><a href="#为什么不用两次握手？" class="headerlink" title="为什么不用两次握手？"></a>为什么不用两次握手？</h4><p> 原因有二： </p>
<ol>
<li>如果只有两次握手，那么服务器端不会知道是否<a href>客户端</a>能够建立连接，会对网络造成性能上的浪费。 </li>
<li>如果只有两次握手，当第一次客户端向服务器端发送的连接请求若没有丢失而是被阻塞在网络中会产生错误。这样客户端长时间没有接受到服务器端传递过来的连接确认报文会再次发起请求连接报文给服务器，那么等到阻塞的报文畅通后，服务器端会响应给客户端，因为只有两次握手这样就又会建立起连接，但这个请求已经报废了，会重复连接对网络资源的浪费。那若有三次握手，则客户端即使收到服务器的确认报文也会认为这是报废的请求，而不会再次发起确认给服务器就不会建立连接，由于服务器收不到确认，就知道客户端没有请求连接。 </li>
</ol>
<h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><ol>
<li>第一次挥手：如果客户端认为数据发送完成，会向服务器端发送数据发送完成的请求字段。 </li>
<li>第二次挥手：服务器收到连接释放请求，会告诉应用层要释放TCP连接，然后会发送ACK包给客户端，进入CLOSE_WAIT状态，表示客户端到服务器的连接已经释放，不接受客户端发送的数据了。但TCP连接是双向的，所以服务器依旧可以发送数据给客户端。 </li>
<li>第三次挥手：服务器端如果还有数据没发送完毕会继续发送，完毕后会向客户端发送连接释放请求，然服务器端进入LAST-ACK状态。 </li>
<li>第四次挥手：客户端收到释放请求后，会向服务器发送确认应答，此时客户端进入TIME-WAIT阶段，这个状态会持续2MSL（最大生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若在该时间内没有服务器的重发请求的话，就进入CLOSED状态，当服务器端接收到确认应答后也进入CLOSED状态。 </li>
</ol>
<h4 id="为什么第四次挥手中客户端进入TIME-WAIT状态要持续2MSL时间后再进入CLOSED状态？"><a href="#为什么第四次挥手中客户端进入TIME-WAIT状态要持续2MSL时间后再进入CLOSED状态？" class="headerlink" title="为什么第四次挥手中客户端进入TIME-WAIT状态要持续2MSL时间后再进入CLOSED状态？"></a>为什么第四次挥手中客户端进入TIME-WAIT状态要持续2MSL时间后再进入CLOSED状态？</h4><p>为了保证服务器能收到客户端的确认应答，若客户端发完确认应答之后直接进入CLOSED状态，若果客户端的确认应答因为网络问题一直没有到达，那么就会造成服务器端不能正常关闭。若服务器端没有收到应答信息，会向客户端<strong>发送超时重传</strong>，此时客户端在2MSL时间内再次收到服务器的连接释放请求，便回再向服务器端重新发送应答信息。 </p>
<h2 id="11-超时重传（ARQ）协议"><a href="#11-超时重传（ARQ）协议" class="headerlink" title="11. 超时重传（ARQ）协议"></a>11. 超时重传（ARQ）协议</h2><h4 id="停止等待ARQ："><a href="#停止等待ARQ：" class="headerlink" title="停止等待ARQ："></a>停止等待ARQ：</h4><p> 当发送端向接收端发送一个报文之后，都要停止等待接收端返回的确认报文，并启动一个定时器，如果在定时器时间内收到对端应答就取消定时器并发送下一段报文。 </p>
<p> 如果报文传输的过程丢失，这时候超时就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。传输效率低，在良好的网络环境下每次都要发送报文都得等待对端的ACK </p>
<h4 id="连续ARQ："><a href="#连续ARQ：" class="headerlink" title="连续ARQ："></a>连续ARQ：</h4><p> 在连续ARQ中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待ARQ协议来说减少了等待时间，提高了效率。 </p>
<h4 id="滑动窗口："><a href="#滑动窗口：" class="headerlink" title="滑动窗口："></a>滑动窗口：</h4><p> 发送端窗口包括已发送但还没收到应答的数据和可以发送但是未发送的数据。发送端窗口是由接收窗口剩余大小决定的，接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况发送窗口的大小，所以发送窗口的大小是不断变化的。当发送端接收到应答报文中，会随之将窗口进行滑动。滑动窗口实现了流量控制机制，接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。 </p>
<h4 id="流量控制机制："><a href="#流量控制机制：" class="headerlink" title="流量控制机制："></a>流量控制机制：</h4><p> 客户端通过发送速率的调整来保证接收方来得及接收，若发送的速率大于接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。 </p>
<h4 id="拥塞处理机制："><a href="#拥塞处理机制：" class="headerlink" title="拥塞处理机制："></a>拥塞处理机制：</h4><p> 主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞状态，发送方就减小发送的速率，这样一方面可以避免增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。 </p>
<p> TCP的拥塞控制机制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。 </p>
<p> 慢启动的基本思想是，就是在传输开始时发送方并不知道网络中的拥塞程度，因此先以较低的速率发送，先进性试探性发送请求，当接收到确认报文后就将发送窗口大小×2，以此类推以指数级速率增长，但不能没有限制，所以有一个阈值限制，当窗口的大小超过阈值限制时就会启动拥塞避免算法。 </p>
<p> 拥塞避免算法是每过一个往返时间窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢调整大小到最佳值。若在传输的过程中定时器超时，这时候TCP会认为网络拥塞了，会马上进入以下步骤：将阈值设置为原来的一半，然后将拥塞窗口的值设为减半后的阈值，然后开始执行阻塞避免算法，使得拥塞窗口缓慢地加性增大。 </p>
<p> 快速重传：一旦接受端收到的报文出现失序的情况，接受端只会回复最后一个顺序正确的报文序号，如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。</p>
<h2 id="12-UDP"><a href="#12-UDP" class="headerlink" title="12. UDP"></a>12. UDP</h2><p> 用户数据报协议，UDP是一个无连接的，不可靠的，基于数据报的传输协议。应用场景：当强调输出性能而非完整性时，如音频和多媒体的实时传输，有个视频流传协议的实时传输就是基于UDP封装而来的。 </p>
<h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><ol>
<li>UDP是无连接的，也就是说不需要建立和断开连接。 </li>
<li>UDP是不可靠的，它不会去备份数据，也不关心对方是否能收到数据。 </li>
<li>UDP没有拥塞控制，一直以恒定的速度发送数据，即使网络条件不好，也不进行速率调整，这样造成的弊端就是在网络条件不好时可能导致丢包。 </li>
</ol>
<h3 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h3><ol>
<li>因为UDP没有TCP那么复杂，不需要保证数据不丢失且有序到达，所以UDP的头部开销小，因为传输数据报文时是很高效的。 </li>
<li>传输方式支持一对多，多对一，多对多，一对一的方式，也就是说UDP提供了单播、多播、广播的功能。 </li>
</ol>
<h2 id="13-从输入URL到页面加载完成的过程"><a href="#13-从输入URL到页面加载完成的过程" class="headerlink" title="13. 从输入URL到页面加载完成的过程"></a>13. 从输入URL到页面加载完成的过程</h2><ol>
<li>在浏览器地址栏输入URL </li>
<li>首先判断是否有永久重定向（301） </li>
<li>浏览器查看资源是否有强缓存，若命中强缓存就直接从缓存中使用，若协商缓存则需要到服务器进行校验资源是否可用。 <ul>
<li>HTTP1.0提供expires，值为一个绝对时间表示缓存过期时间 </li>
<li>HTTP1.1增加了一个cache-control：max-age，值为以秒为单位的最大缓存过期时间。还有no-cache，no-store，分别表示可以缓存但会立即失效和不能缓存。 </li>
</ul>
</li>
<li>浏览器解析URL获取协议，主机，端口，path。 </li>
<li>浏览器组装一个HTTP（GET）请求报文。 </li>
<li>DNS解析，查找过程如下： <ul>
<li>首先查找浏览器缓存； </li>
<li>第二查找本机缓存 </li>
<li>第三查找hosts文件 </li>
<li>第四路由器缓存 </li>
<li>第五ISP DNS缓存 </li>
<li>第六DNS查询（递归查询、迭代查询） </li>
</ul>
</li>
<li>端口建立TCP连接，三次握手： <ol>
<li>客户端发送一个TCP的SYN=1，seq=x的连接请求到服务器端。 </li>
<li>服务器端返回SYN=1，ACK=x+1，Seq=Y的确认连接字段。 </li>
<li>客户端收到确认连接字段后发生ACK=Y+1，seq=z </li>
</ol>
</li>
<li>TCP连接建立后发起HTTP请求 </li>
<li>服务器接收到请求并解析，将请求转发到服务程序。 </li>
<li>服务器检查HTTP请求头部是否有缓存验证信息，如果缓存未过期，返回304状态码 </li>
<li>处理程序读取完整请求并准备HTTP响应，同时可能需要查询数据库等操作 </li>
<li>服务器将相应报文通过TCP连接发送会浏览器。 </li>
<li>浏览器接收到HTTP响应，根据情况选择是否关闭TCP连接，若关闭的话四次挥手。 <ol>
<li>浏览器端首先向服务器端发送数据已发送完毕的报文 </li>
<li>服务器端接收到之后，返回确认报文同意浏览器停止发送数据，但此时服务器端依旧可以接收未接收完的数据，并且可以返回数据给浏览器端。 </li>
<li>服务器端将所有数据返回给客户端之后，向客户端发送请求连接释放报文。 </li>
<li>客户端收到连接释放报文后，向服务器端返回确认连接释放报文。 </li>
</ol>
</li>
<li>浏览器接收到服务端的响应报文后，会检查响应状态码，根据不同的状态码处理不同的情况。 </li>
<li>如果资源可以缓存，进行缓存。 </li>
<li>将响应内容进行解码。 </li>
<li>根据资源类型决定如何处理。 </li>
<li>若资源类型为html类型，解析html文档，构建DOM树，并下载相关资源，构造CSSOM树，执行js脚本。 </li>
<li>首先构造DOM树 </li>
<li>解析过程中如果遇到图片、样式表、js文件便启动下载 </li>
<li>构建CSSOM树 </li>
<li>根据DOM树和CSSOM树构建渲染树： <ol>
<li>从DOM树的根节点遍历所有可见节点。 </li>
<li>对每一个节点找到恰当的CSSOM规则并应用 </li>
<li>发布可视节点的内容和计算样式 </li>
</ol>
</li>
<li>js脚本解析： <ol>
<li>浏览器创建document对象并解析html，将解析的文本和节点添加到文档中。 </li>
<li>html解析器遇到没有defer和async属性的script时，将他们添加到文档中，然后去执行脚本语句。在脚本下载和执行时html解析器会暂停。直到script下载和执行完毕 </li>
<li>当解析器遇到async属性的script时，开始下载脚本但会继续解析文档，当脚本下载完毕时就会立刻回过头去执行该脚本，但是解析器不会停下来等它下载。 </li>
<li>当解析器遇到defer属性的script时，defer脚本会在文档解析完毕时按照顺序执行，并且可以访问完整文档。 </li>
<li>浏览器在document对象上触发DOMContentLoaded事件 </li>
<li>此时文档完全解析完成，浏览器可能还在等待图片等内容加载，等待这些内容完成载入并且所有异步脚本完成载入和执行之后，window会触发loaded事件 </li>
</ol>
</li>
<li>显示页面（html解析过程中会逐步显示页面）。</li>
</ol>
<h2 id="14-缓存"><a href="#14-缓存" class="headerlink" title="14. 缓存"></a>14. 缓存</h2><h3 id="1-强缓存："><a href="#1-强缓存：" class="headerlink" title="1. 强缓存："></a>1. 强缓存：</h3><p> 强缓存就是直接向浏览器缓存中查找结果，并且根据该结果的缓存规则决定是否使用该缓存的过程。主要有三种情况：</p>
<ol>
<li><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器端发起请求。</p>
</li>
<li><p>存在该缓存结果和缓存标识，但结果已失效，只返回该缓存标识，强制缓存失效，则使用协商缓存。</p>
</li>
<li><p>存在该缓存结果和缓存标识，结果仍有效，使用强制缓存。 </p>
<p>控制强制缓存的http头部字段为expires和cache-control。 </p>
<p>Expires：是http1.0中控制缓存的字段，值为服务器返回请求结果缓存的到期时间，是一个绝对值。缺点是假如客户端和服务器端时间不同步，那么就产生误差，则强制缓存有效时间不准确。 </p>
<p>Cache-Control：是到了http1.1中，Expires被Cache-Control取代，主要取值为： </p>
</li>
<li><p>no-cache：客户端缓存内容，但是否使用缓存则需要经过协商缓存来验证决定。 </p>
</li>
<li><p>no-store：所有内容都不会被缓存。 </p>
</li>
<li><p>max-age：缓存内容将在多少秒失效。 </p>
</li>
<li><p>public：所有内容都会被缓存（包括客户端和服务器端） </p>
</li>
<li><p>private：所有内容只有客户端可以缓存，是cache-control的默认值。 </p>
</li>
</ol>
<h3 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2. 协商缓存"></a>2. 协商缓存</h3><p> 协商缓存就是浏览器缓存中的缓存标识失效，即强制缓存失效后，浏览器携带缓存标识向服务器端发起请求。由服务器根据缓存标识决定是否使用协商缓存，主要有两种情况 </p>
<ol>
<li><p>协商缓存生效，返回304状态码，即该自愿无更新。 </p>
</li>
<li><p>协商缓存失效，返回200状态码和请求结果，即该资源更新了返回更新后的资源。 </p>
<p>协商缓存的标识也是在响应报文的HTTP头部中和请求结果一起返回给浏览器端，主要字段有Last-Modified、If-Modified-Since和Etag、If-None-Match。其中Etag、If-None-Match比Last-Modified、If-Modified-Since优先级高。 </p>
</li>
<li><p>Last-Modified/If-Modified-Since </p>
<ol>
<li>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。 </li>
<li>If-Modified-Since是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到这个请求头和该资源在服务器的最后修改时间进行对比，若服务器的资源修改时间大于If-Modified-Since，则说明资源被更新，需要重新返回资源，状态码为200，否则则返回304，代表资源无更新，可继续使用缓存文件。 </li>
</ol>
</li>
<li><p>Etag/If-None-Match：</p>
<ol>
<li>Etag是服务器响应请求时，返回当前资源文件的唯一标识并由服务器端产生。</li>
<li>If-None-Match是客户端再次发起请求时，携带上次请求返回的唯一标识Etag值，通过此字段告知服务器该资源上次请求返回的唯一标识值，服务器收到后与该资源在服务器的Etag进行对比，若一致则说明资源无更新，返回304状态码，若不一致说明资源更新，返回更新的资源以及200状态码。</li>
</ol>
</li>
</ol>
<h2 id="15-跨域"><a href="#15-跨域" class="headerlink" title="15. 跨域"></a>15. 跨域</h2><p> 同源策略：端口、域名、协议相同。目的是为了保证用户信息的安全，防止恶意网站窃取数据。 </p>
<h3 id="限制范围："><a href="#限制范围：" class="headerlink" title="限制范围："></a>限制范围：</h3><p> Cookies、LocalStorage、IndexDB无法读取；DOM无法获取；AJAX请求不能发送。 </p>
<h3 id="CORS跨域资源请求"><a href="#CORS跨域资源请求" class="headerlink" title="CORS跨域资源请求"></a>CORS跨域资源请求</h3><p> 浏览器在请求一个跨域资源时，如果是ajax请求会在请求头部添加一个origin字段，但它目前还不知道目标服务器端是否允许跨域请求，浏览器向服务器端发送ajax请求，如果服务器端返回的头中有Access-Control-Allow-Origin字段，并且值为允许访问的网站或者*字符的话，就允许跨域请求，否则会把请求内容忽略掉，并且在控制台报错。 </p>
<h3 id="CORS限制"><a href="#CORS限制" class="headerlink" title="CORS限制"></a>CORS限制</h3><p> 允许的请求方法：GET \ POST \ HEAD </p>
<p> 允许的content-type：text/plain, multipart/form-data, application/x-www-form-urlencoded。其他请求方式和其他content-type需要通过域请求验证后然后才能发送 </p>
<h3 id="CORS预请求"><a href="#CORS预请求" class="headerlink" title="CORS预请求"></a>CORS预请求</h3><p> 跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站有权访问哪些资源。服务器在HTTP头部加入允许请求的方法和content-type后，其他指定的方法和content-type就可以成功请求了。 </p>
<p> ‘Access-control-allow-headers’: ‘允许Content-type’ </p>
<p> ’Access-Control-Allow-Methods‘：’允许的请求方法‘ </p>
<p> ’Access-Control-Max-Age‘：’预请求允许其他方法和类型传输的时间‘ </p>
<h3 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h3><p> 浏览器上虽然有同源限制，但是像script标签，link标签，img标签，iframe标签这种在标签上通过src地址来加载一些内容的时候浏览器是允许进行跨域请求的。 </p>
<p> 所以JSONP的原理就是： </p>
<ul>
<li>创建一个script标签，这个script标签的src就是请求的地址 </li>
<li>这个script标签插入到DOM中，浏览器就根据src地址访问服务器资源 </li>
<li>​    返回的资源是一个文本，但是因为是在script标签中，浏览器会执行它。   </li>
<li>​    而这个文本恰好是函数调用的形式，也就是函数名（数据），浏览器会把它当做JS代码来执行调用这个函数。   </li>
<li>​    只要提前约定好这个函数名，并且这个函数存在于window对象中，就可以把数据传递给处理函数。</li>
</ul>
<h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>希望自己能找到一个好实习，也希望某一点对小伙伴们有所帮助  </p>
<p><a href="https://www.nowcoder.com/discuss/412972?source_id=profile_create&channel=666" target="_blank" rel="noopener">借鉴文章 - 牛客网</a>   </p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        
                                            <!--MOB SHARE BEGIN-->
<a><div class="-mob-share-open article-share-link">分享</div></a>
<div class="-mob-share-ui" style="display: none; display: flex; align-items: center; align-content: center;">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
    </ul>
    <div style="height: 100%; width: 100%">
        <div class="-mob-share-close" style="position:relative; margin: -26em auto; width: 80px; height: 40px; font-size: 14px; color: #fff; background-color: #4593e9; border-radius: 15px;">取消</div>
    </div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="/lindada-blog/js/mob-share.js"></script>
<!--MOB SHARE END-->

                                        
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/lindada-blog/tags/%E9%9D%A2%E8%AF%95%E5%B0%8F%E5%B1%8B/" rel="tag">面试小屋</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/lindada-blog/2020/12/29/%E6%9E%97%E5%A4%A7%E4%BA%BA%E7%9A%84%E9%9D%A2%E8%AF%95%E5%B0%8F%E5%B1%8B-Git%E5%8E%9F%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            林大人的面试小屋-Git原理
          
        </div>
      </a>
    
    
      <a href="/lindada-blog/2020/12/29/%E6%9E%97%E5%A4%A7%E4%BA%BA%E7%9A%84%E9%9D%A2%E8%AF%95%E5%B0%8F%E5%B1%8B-Web%E5%AE%89%E5%85%A8-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">林大人的面试小屋-Web安全/操作系统/性能优化</div>
      </a>
    
  </nav>


            

                
                    
    <div class="vcomments" id="vcomments"></div>
    
<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

        <script>
            new Valine({
                el: '#vcomments',
                appId: 'vtOOBRQNx6g17peggpfzBROa-9Nh9j0Va',
                appKey: 'Q1DgaTCfUeYjMOqoTAH8TX9M',
                notify: 'false',
                verify: 'true',
                avatar: 'mp',
                pageSize: '20',
                placeholder: '✨悄悄地对小屋说...'
            })
        </script>
        
                        
                            

</article>

</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li>访客数 <i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li>阅读量 <i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>

    </div>
    <ul class="list-inline">
      <li>&copy; 2021 大大的小屋</li> |
      <li> Gitee主页 by <a href="https://gitee.com/lin_daren" target="_blank">林大大的Gitee</a></li> |
      <li> Wechat by <span class="footer-title">dadaLin_0809</span></li>
      <li> Email by <span class="footer-title">809751956@qq.com</span></li> |
    </ul>
  </div>
</footer>

<style>
    .footer-title {
        color: darkcyan;
        font-weight: bold;
    }
</style>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/lindada-blog/"><img src="/lindada-blog/images/star.svg" alt="大大的小屋"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/lindada-blog/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/lindada-blog/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/lindada-blog/js/jquery-2.0.3.min.js"></script>


<script src="/lindada-blog/js/jquery.justifiedGallery.min.js"></script>


<script src="/lindada-blog/js/lazyload.min.js"></script>


<script src="/lindada-blog/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/lindada-blog/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/lindada-blog/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/lindada-blog/js/ocean.js"></script>


<script src="/lindada-blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/lindada-blog/live2dw/assets/assets/shizuku.model.json"},"display":{"position":"left","width":180,"height":360,"top":"-40px","right":"25px"},"mobile":{"show":true}});</script></body>
</html>
